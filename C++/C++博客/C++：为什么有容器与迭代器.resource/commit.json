{"compress":true,"commitItems":[["35171774-24bb-4f29-b269-edd79e982df2",1542811161903,"",[[1542811102811,["gjx16@GJXAIOU",[[1,0,"# C++：为什么有容器与迭代器\n\n\n\n"]],[0,0],[19,19]]],[1542811121139,["gjx16@GJXAIOU",[[1,18,"个人理解：\n\nvector类似于栈，尾端插入删除。\n\ndeque类似于双向栈，头尾插入与删除。\n\nlist类似于双链表。\n\n迭代器类似于指针，提供访问容器的方法。\n\n--------------------------------------------------------------------------\n\nc++中的容器包括哪些？\n\nC++中的容器类包括“顺序存储结构”和“关联存储结构”。\n\n前者包括vector，list，deque等；\n\n后者包括set，map，multiset，multimap等。\n\n若需要存储的元素数在编译器间就可以确定，可以使用数组来存储，否则，就需要用到容器类了。\n\n1、vector\n\n连续存储结构，每个元素在内存上是连续的，由数组实现；\n\n支持高效的随机访问和在尾端插入/删除操作，但其他位置的插入/删除操作效率低下；\n\nvector是使用 new 和 delete 来管理内存的；\n\nvector可以嵌套定义： vector <vector <int>>   array2(3);\n\n使用Vector实现二维数组：vector<vector<int> > Array(M, vector<int>(N));   //记得一定要有空格，不然会报错\n\n使用数组初始化vector：int a[7]={1,2,3,4,5,6,7};  vector<int> ivec(a,a+7);\n\nvector用法\n\n在C++中VECTOR的size()和capacity()取值：前者是实际大小，后者是分配空间大小（按指数增长）\n\nC++ STL vector：sizeof(vector)：这里有个陷阱——vector的大小由size获得，sizeof（vector）取决于vector实现，与数据量无关\n\n2、deque\n\n连续存储结构，即其每个元素在内存上也是连续的，类似于vector。\n\n不同之处在于，deque提供了两级数组结构，第一级完全类似于vector，代表实际容器；另一级维护容器的首位地址。\n\n这样，deque除了具有vector的所有功能外，还支持高效的首端插入/删除操作。\n\n3、list\n非连续存储结构，具有双链表结构，每个元素维护一对前向和后向指针，因此支持前向/后向遍历。\n\n支持高效的随机插入/删除操作，但随机访问效率低下，且由于需要额外维护指针，开销也比较大。\n\n-----------------------------------------------------------------------\nvector V.S. list V.S. deque\n\na、若需要随机访问操作，则选择vector；\n\nb、若已经知道需要存储元素的数目， 则选择vector；\n\nc、若需要随机插入/删除（不仅仅在两端），则选择list\n\nd、只有需要在首端进行插入/删除操作的时候，才选择deque，否则都选择vector。\n\ne、若既需要随机插入/删除，又需要随机访问，则需要在vector与list间做个折中。\n\nf、当要存储的是大型负责类对象时，list要优于vector；当然这时候也可以用vector来存储指向对象的指针，同样会取得较高的效率，但是指针的维护非常容易出错，因此不推荐使用。\n\ncapacity V.S size\n\na、capacity是容器需要增长之前，能够盛的元素总数；只有连续存储的容器才有capacity的概念（例如vector，deque，string），list不需要capacity。\n\nb、size是容器当前存储的元素的数目。\n\nc、vector默认的容量初始值，以及增长规则是依赖于编译器的。\n\n6、用vector存储自定义类对象时，自定义类对象须满足：\n\na、有可供调用的无参构造函数（默认的或自定义的）；\n\nb、有可用的拷贝赋值函数（默认的或自定义的）\n\n-----------------------------------------------------------------------\n迭代器iterator\n\n迭代器提供对一个容器中的对象的访问方法，并且定义了容器中对象的范围。迭代器就如同一个指针，但不仅仅是指针。\n\n迭代器是跟容器紧密结合的，不同的容器，它的迭代器不同。\n\n他们有共同的目标——通过该迭代器来遍历访问这个容器里面的元素。\n\n这样带来的好处是在STL设计算法时，可以脱离容器而设计更加通用的算法。\n\n比如，在容器中查找一个元素。查找，这个操作一般来说就是遍历整个集合，然后找到那个要找的元素，但是，如果没有迭代器，我们需要为vector和List设计两个查找算法，因为找下一个元素在vector和List中的操作不同。同样的思想却要两套代码，显然这是不优秀的。\n\n有了模板，我们可以将算法和特定的数据分离开来，而有了迭代器，我们可以将算法和特定的容器分离开来。\n\nvector与deque的迭代器支持算术运算，list的迭代器只能进行++/--操作，不支持普通的算术运算。\n\n\n\n\n\n\n--------------------- \n作者：CS青雀 \n来源：CSDN \n原文：https://blog.csdn.net/ztf312/article/details/50898391 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[18,18],[2259,2259]]],[1542811129986,["gjx16@GJXAIOU",[[-1,2135,"--------------------- \n作者：CS青雀 \n来源：CSDN \n原文：https://blog.csdn.net/ztf312/article/details/50898391 \n版权声明：本文为博主原创文章，转载请附上博文链接！\n"]],[2134,2259],[2134,2134]]],[1542811135944,["gjx16@GJXAIOU",[[1,18,"\n"]],[17,17],[18,18]]],[1542811137331,["gjx16@GJXAIOU",[[1,18,"="],[-1,449," "],[1,450," "],[-1,472," "],[1,473," "],[-1,548," "],[1,549," "],[-1,608," "],[1,609," "]],[18,18],[19,19]]],[1542811137479,["gjx16@GJXAIOU",[[1,19,"==="]],[19,19],[20,20]]],[1542811139445,["gjx16@GJXAIOU",[[1,20,"文章"]],[20,20],[22,22]]],[1542811140975,["gjx16@GJXAIOU",[[-1,20,"文章"]],[22,22],[20,20]]],[1542811146071,["gjx16@GJXAIOU",[[1,20,"粘贴补全"]],[20,20],[24,24]]],[1542811146871,["gjx16@GJXAIOU",[[-1,22,"补全"]],[24,24],[22,22]]],[1542811152675,["gjx16@GJXAIOU",[[1,22,"不全，原文地震仪"]],[22,22],[30,30]]],[1542811153810,["gjx16@GJXAIOU",[[-1,27,"地震仪"]],[30,30],[27,27]]],[1542811155419,["gjx16@GJXAIOU",[[1,27,"地址："]],[27,27],[30,30]]],[1542811157266,["gjx16@GJXAIOU",[[1,33,"\n"]],[32,32],[33,33]]],[1542811157424,["gjx16@GJXAIOU",[[1,34,"\n"]],[33,33],[34,34]]],[1542811162487,["gjx16@GJXAIOU",[[1,34,"https://blog.csdn.net/ztf312/article/details/50898391"]],[34,34],[87,87]]],[1542811164202,["gjx16@GJXAIOU",[[1,88,"\n"]],[87,87],[88,88]]]],null,"gjx16@GJXAIOU"],["2c4e21b3-a4e6-4311-8e03-602c01fce0ed",1542849214974,"# C++：为什么有容器与迭代器\n\n==粘贴不全，原文地址：==\n\nhttps://blog.csdn.net/ztf312/article/details/50898391\n\n个人理解：\n\nvector类似于栈，尾端插入删除。\n\ndeque类似于双向栈，头尾插入与删除。\n\nlist类似于双链表。\n\n迭代器类似于指针，提供访问容器的方法。\n\n--------------------------------------------------------------------------\n\nc++中的容器包括哪些？\n\nC++中的容器类包括“顺序存储结构”和“关联存储结构”。\n\n前者包括vector，list，deque等；\n\n后者包括set，map，multiset，multimap等。\n\n若需要存储的元素数在编译器间就可以确定，可以使用数组来存储，否则，就需要用到容器类了。\n\n1、vector\n\n连续存储结构，每个元素在内存上是连续的，由数组实现；\n\n支持高效的随机访问和在尾端插入/删除操作，但其他位置的插入/删除操作效率低下；\n\nvector是使用 new 和 delete 来管理内存的；\n\nvector可以嵌套定义： vector <vector <int>>   array2(3);\n\n使用Vector实现二维数组：vector<vector<int> > Array(M, vector<int>(N));   //记得一定要有空格，不然会报错\n\n使用数组初始化vector：int a[7]={1,2,3,4,5,6,7};  vector<int> ivec(a,a+7);\n\nvector用法\n\n在C++中VECTOR的size()和capacity()取值：前者是实际大小，后者是分配空间大小（按指数增长）\n\nC++ STL vector：sizeof(vector)：这里有个陷阱——vector的大小由size获得，sizeof（vector）取决于vector实现，与数据量无关\n\n2、deque\n\n连续存储结构，即其每个元素在内存上也是连续的，类似于vector。\n\n不同之处在于，deque提供了两级数组结构，第一级完全类似于vector，代表实际容器；另一级维护容器的首位地址。\n\n这样，deque除了具有vector的所有功能外，还支持高效的首端插入/删除操作。\n\n3、list\n非连续存储结构，具有双链表结构，每个元素维护一对前向和后向指针，因此支持前向/后向遍历。\n\n支持高效的随机插入/删除操作，但随机访问效率低下，且由于需要额外维护指针，开销也比较大。\n\n-----------------------------------------------------------------------\nvector V.S. list V.S. deque\n\na、若需要随机访问操作，则选择vector；\n\nb、若已经知道需要存储元素的数目， 则选择vector；\n\nc、若需要随机插入/删除（不仅仅在两端），则选择list\n\nd、只有需要在首端进行插入/删除操作的时候，才选择deque，否则都选择vector。\n\ne、若既需要随机插入/删除，又需要随机访问，则需要在vector与list间做个折中。\n\nf、当要存储的是大型负责类对象时，list要优于vector；当然这时候也可以用vector来存储指向对象的指针，同样会取得较高的效率，但是指针的维护非常容易出错，因此不推荐使用。\n\ncapacity V.S size\n\na、capacity是容器需要增长之前，能够盛的元素总数；只有连续存储的容器才有capacity的概念（例如vector，deque，string），list不需要capacity。\n\nb、size是容器当前存储的元素的数目。\n\nc、vector默认的容量初始值，以及增长规则是依赖于编译器的。\n\n6、用vector存储自定义类对象时，自定义类对象须满足：\n\na、有可供调用的无参构造函数（默认的或自定义的）；\n\nb、有可用的拷贝赋值函数（默认的或自定义的）\n\n-----------------------------------------------------------------------\n迭代器iterator\n\n迭代器提供对一个容器中的对象的访问方法，并且定义了容器中对象的范围。迭代器就如同一个指针，但不仅仅是指针。\n\n迭代器是跟容器紧密结合的，不同的容器，它的迭代器不同。\n\n他们有共同的目标——通过该迭代器来遍历访问这个容器里面的元素。\n\n这样带来的好处是在STL设计算法时，可以脱离容器而设计更加通用的算法。\n\n比如，在容器中查找一个元素。查找，这个操作一般来说就是遍历整个集合，然后找到那个要找的元素，但是，如果没有迭代器，我们需要为vector和List设计两个查找算法，因为找下一个元素在vector和List中的操作不同。同样的思想却要两套代码，显然这是不优秀的。\n\n有了模板，我们可以将算法和特定的数据分离开来，而有了迭代器，我们可以将算法和特定的容器分离开来。\n\nvector与deque的迭代器支持算术运算，list的迭代器只能进行++/--操作，不支持普通的算术运算。\n\n\n\n\n\n\n\n",[[1542849156250,["gjx16@GJXAIOU",[[1,89,"**"],[1,94,"**"]],[89,94],[89,98]]],[1542849159933,["gjx16@GJXAIOU",[[1,100,"-- "]],[100,100],[103,103]]],[1542849163129,["gjx16@GJXAIOU",[[-1,100,"-- "]],[103,103],[100,100]]],[1542849163810,["gjx16@GJXAIOU",[[1,100,"- "]],[100,100],[102,102]]],[1542849165767,["gjx16@GJXAIOU",[[1,122,"- "]],[122,122],[124,124]]],[1542849167088,["gjx16@GJXAIOU",[[1,146," "]],[146,146],[147,147]]],[1542849168226,["gjx16@GJXAIOU",[[-1,146," "]],[147,147],[146,146]]],[1542849168627,["gjx16@GJXAIOU",[[1,146,"- "]],[146,146],[148,148]]],[1542849172251,["gjx16@GJXAIOU",[[1,161,"- "]],[161,161],[163,163]]],[1542849175653,["gjx16@GJXAIOU",[[1,260,"- "]],[260,260],[262,262]]],[1542849178586,["gjx16@GJXAIOU",[[-1,261," "]],[260,260],[261,261]]],[1542849179383,["gjx16@GJXAIOU",[[1,261,"-"]],[261,261],[262,262]]],[1542849180931,["gjx16@GJXAIOU",[[-1,260,"--"]],[262,262],[260,260]]],[1542849181129,["gjx16@GJXAIOU",[[-1,259,"\n"]],[260,260],[259,259]]],[1542849183849,["gjx16@GJXAIOU",[[1,259,"**"],[1,271,"**"]],[259,271],[259,275]]],[1542849187579,["gjx16@GJXAIOU",[[-1,276,"\n"]],[277,277],[276,276]]],[1542849187925,["gjx16@GJXAIOU",[[1,276," "]],[276,276],[277,277]]],[1542849189436,["gjx16@GJXAIOU",[[-1,276," "]],[277,277],[276,276]]],[1542849190661,["gjx16@GJXAIOU",[[1,276,"- "]],[276,276],[278,278]]],[1542849193220,["gjx16@GJXAIOU",[[1,308,"  - "]],[308,308],[312,312]]],[1542849195670,["gjx16@GJXAIOU",[[1,337,"  - "]],[337,337],[341,341]]],[1542849204193,["gjx16@GJXAIOU",[[1,419,"**"],[1,427,"**"]],[419,427],[419,431]]],[1542849211835,["gjx16@GJXAIOU",[[1,433,"- "]],[433,433],[435,435]]],[1542849213109,["gjx16@GJXAIOU",[[1,463,"- "]],[463,463],[465,465]]],[1542849216285,["gjx16@GJXAIOU",[[1,506,"-"]],[506,506],[507,507]]],[1542849220187,["gjx16@GJXAIOU",[[1,540,"- "]],[540,540],[542,542]]],[1542849222110,["gjx16@GJXAIOU",[[1,592,"- "]],[592,592],[594,594]]],[1542849224126,["gjx16@GJXAIOU",[[1,676,"- "]],[676,676],[678,678]]],[1542849227451,["gjx16@GJXAIOU",[[1,745,"**"],[1,753,"**"]],[745,753],[745,757]]]],null,"gjx16@GJXAIOU"]]}