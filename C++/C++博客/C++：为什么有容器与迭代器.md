# C++：为什么有容器与迭代器

==粘贴不全，原文地址：==

https://blog.csdn.net/ztf312/article/details/50898391

**个人理解：**

- vector类似于栈，尾端插入删除。

- deque类似于双向栈，头尾插入与删除。

- list类似于双链表。

- 迭代器类似于指针，提供访问容器的方法。

--------------------------------------------------------------------------
**c++中的容器包括哪些？**
- C++中的容器类包括“顺序存储结构”和“关联存储结构”。

  - 前者包括vector，list，deque等；

  - 后者包括set，map，multiset，multimap等。

若需要存储的元素数在编译器间就可以确定，可以使用数组来存储，否则，就需要用到容器类了。

**1、vector**

- 连续存储结构，每个元素在内存上是连续的，由数组实现；

- 支持高效的随机访问和在尾端插入/删除操作，但其他位置的插入/删除操作效率低下；

- vector是使用 new 和 delete 来管理内存的；

- vector可以嵌套定义： vector <vector <int>>   array2(3);

- 使用Vector实现二维数组：vector<vector<int> > Array(M, vector<int>(N));   //记得一定要有空格，不然会报错

- 使用数组初始化vector：int a[7]={1,2,3,4,5,6,7};  vector<int> ivec(a,a+7);

**vector用法**

在C++中VECTOR的size()和capacity()取值：前者是实际大小，后者是分配空间大小（按指数增长）

C++ STL vector：sizeof(vector)：这里有个陷阱——vector的大小由size获得，sizeof（vector）取决于vector实现，与数据量无关

2、deque

连续存储结构，即其每个元素在内存上也是连续的，类似于vector。

不同之处在于，deque提供了两级数组结构，第一级完全类似于vector，代表实际容器；另一级维护容器的首位地址。

这样，deque除了具有vector的所有功能外，还支持高效的首端插入/删除操作。

3、list
非连续存储结构，具有双链表结构，每个元素维护一对前向和后向指针，因此支持前向/后向遍历。

支持高效的随机插入/删除操作，但随机访问效率低下，且由于需要额外维护指针，开销也比较大。

-----------------------------------------------------------------------
vector V.S. list V.S. deque

a、若需要随机访问操作，则选择vector；

b、若已经知道需要存储元素的数目， 则选择vector；

c、若需要随机插入/删除（不仅仅在两端），则选择list

d、只有需要在首端进行插入/删除操作的时候，才选择deque，否则都选择vector。

e、若既需要随机插入/删除，又需要随机访问，则需要在vector与list间做个折中。

f、当要存储的是大型负责类对象时，list要优于vector；当然这时候也可以用vector来存储指向对象的指针，同样会取得较高的效率，但是指针的维护非常容易出错，因此不推荐使用。

capacity V.S size

a、capacity是容器需要增长之前，能够盛的元素总数；只有连续存储的容器才有capacity的概念（例如vector，deque，string），list不需要capacity。

b、size是容器当前存储的元素的数目。

c、vector默认的容量初始值，以及增长规则是依赖于编译器的。

6、用vector存储自定义类对象时，自定义类对象须满足：

a、有可供调用的无参构造函数（默认的或自定义的）；

b、有可用的拷贝赋值函数（默认的或自定义的）

-----------------------------------------------------------------------
迭代器iterator

迭代器提供对一个容器中的对象的访问方法，并且定义了容器中对象的范围。迭代器就如同一个指针，但不仅仅是指针。

迭代器是跟容器紧密结合的，不同的容器，它的迭代器不同。

他们有共同的目标——通过该迭代器来遍历访问这个容器里面的元素。

这样带来的好处是在STL设计算法时，可以脱离容器而设计更加通用的算法。

比如，在容器中查找一个元素。查找，这个操作一般来说就是遍历整个集合，然后找到那个要找的元素，但是，如果没有迭代器，我们需要为vector和List设计两个查找算法，因为找下一个元素在vector和List中的操作不同。同样的思想却要两套代码，显然这是不优秀的。

有了模板，我们可以将算法和特定的数据分离开来，而有了迭代器，我们可以将算法和特定的容器分离开来。

vector与deque的迭代器支持算术运算，list的迭代器只能进行++/--操作，不支持普通的算术运算。







