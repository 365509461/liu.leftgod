# 字节码

分析工具：IDEA + Jclasslib + WinHex（IDEA 中可以使用 HexView 代替）

部分图片可替换为：https://zhuanlan.zhihu.com/p/25823310

------

- ==Java 虚拟机不和包括 java 在内的任何语言绑定，它只与 “Class” 特定的二进制文件格式关联==，实现 JVM 与语言无关系，例如 Groovy、Scala 等均可以在 JVM 上运行，虚拟机并不关心 Class 的来源为何种语言，因此 Java 规范拆分为： Java 编程规范和 Java 虚拟机规范，Class 文件中包含Java 虚拟机指令集和符号表以及若干其他辅助信息。

- 代码编译的结果不在是二进制本地机器码（Native Code），而是字节码文件。（其与操作系统、机器指令集无关）
- 字节码命令提供的语义比 Java 语言本身更加强大，因此字节码可以支撑 Java 语言本身无法支持的语言特性，因此可以为其他语言提供支持；
- **任何一个 Class 文件都对应着唯一一个类或者接口的定义信息，但是类或者接口并不一定都得定义在文件中（例如可以通过类加载器直接生成）**，因此这里的 Class 文件格式不一定是以磁盘文件形式存在。
-  Class 文件是一组以 8 位字节为基础单位的二进制流；

------

## 一、字节码组成部分

- Java跨平台的原因是 JVM 不跨平台
- 下面将从该程序编译生成的字节码文件和其对应的十六进制进行分析

```java
package com.gjxaiou.bytecode;

public class MyTest1{
    private int a=1;
    public int getA(){
        return a;
    }
    public void setA(int a){
        this.a=a;
    }
}
```

### （一）反编译

- 使用对通过 Build 编译生成 MyTest1.class 文件，然后使用反编译命令：`javap` ，对文件进行反编译：`E:\Program\Java\JVM\DemoByMyself\out\production\DemoByMyself\com\gjxaiou\bytecode>javap MyTest1` 后面不要加 `.class`，因为它本质上是会找 MyTest1.java 类，生成以下数据

```java
警告: 二进制文件MyTest1包含com.gjxaiou.bytecode.MyTest1
Compiled from "MyTest1.java"
public class com.gjxaiou.bytecode.MyTest1 {
   // 因为没有指定构造器，所以编译器会自动为我们提供一个构造器 
  public com.gjxaiou.bytecode.MyTest1();
  public int getA();
  public void setA(int);
}
```

- 为了看到更加详细的 Class 文件结构，使用`javap -c` 会打印出包括助记符在内的更加详尽的信息，`E:\Program\Java\JVM\DemoByMyself\out\production\DemoByMyself\com\gjxaiou\bytecode>javap -c MyTest1`，生成以下数据：

```java
Compiled from "MyTest1.java"
public class com.gjxaiou.bytecode.MyTest1 {
  public com.gjxaiou.bytecode.MyTest1();
  // Code: 表示方法执行的代码
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: aload_0
       5: iconst_1
       6: putfield      #2                  // Field a:I
       9: return

  public int getA();
    Code:
       0: aload_0
       1: getfield      #2                  // Field a:I
       4: ireturn

  public void setA(int);
    Code:
       0: aload_0
       1: iload_1
       2: putfield      #2                  // Field a:I
       5: return
}

```

- **一般使用这个命令**：使用反编译命令：`javap -verbose`打印更多东西 ：`E:\Program\Java\JVM\DemoByMyself\out\production\DemoByMyself\com\gjxaiou\bytecode>javap -verbose MyTest1`，生成以下数据

```java
Classfile /E:/Program/Java/JVM/DemoByMyself/out/production/DemoByMyself/com/gjxaiou/bytecode/MyTest1.class
  Last modified 2019-12-6; size 487 bytes
  MD5 checksum b323038a82fa26c3db2caeef3f5f3dea
  Compiled from "MyTest1.java"
public class com.gjxaiou.bytecode.MyTest1
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#20         // java/lang/Object."<init>":()V
   #2 = Fieldref           #3.#21         // com/gjxaiou/bytecode/MyTest1.a:I
   #3 = Class              #22            // com/gjxaiou/bytecode/MyTest1
   #4 = Class              #23            // java/lang/Object
   #5 = Utf8               a
   #6 = Utf8               I
   #7 = Utf8               <init>
   #8 = Utf8               ()V           // 没有任何参数，返回值为 void
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               LocalVariableTable
  #12 = Utf8               this
  #13 = Utf8               Lcom/gjxaiou/bytecode/MyTest1;
  #14 = Utf8               getA
  #15 = Utf8               ()I        // 不接受任何参数，返回值为 int
  #16 = Utf8               setA
  #17 = Utf8               (I)V
  #18 = Utf8               SourceFile//这个和下面两个常量值表示该class文件是由什么源文件编译得到
  #19 = Utf8               MyTest1.java
  #20 = NameAndType        #7:#8          // "<init>":()V
  #21 = NameAndType        #5:#6          // a:I
  #22 = Utf8               com/gjxaiou/bytecode/MyTest1
  #23 = Utf8               java/lang/Object
{
  public com.gjxaiou.bytecode.MyTest1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: iconst_1
         6: putfield      #2                  // Field a:I
         9: return
      LineNumberTable:
        line 3: 0
        line 4: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      10     0  this   Lcom/gjxaiou/bytecode/MyTest1;

  public int getA();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field a:I
         4: ireturn
      LineNumberTable:
        line 6: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/gjxaiou/bytecode/MyTest1;

  public void setA(int);
    descriptor: (I)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: iload_1
         2: putfield      #2                  // Field a:I
         5: return
      LineNumberTable:
        line 9: 0
        line 10: 5
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       6     0  this   Lcom/gjxaiou/bytecode/MyTest1;
            0       6     1     a   I
}
SourceFile: "MyTest1.java"

```

- 使用 WinHex 打开 MyTest1.class 二进制文件：
  ![image-20191206222429551](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191206222429551.png)

上面是按照十六进制的单字节格式进行显示，每个字节之间使用空格隔开，一个字节是8位，一个16进制数（就是上面一个字母或者一个数）占据四位，所以两个在一起正好是一个字节；

### （二）字节码整体结构

#### 1.概述

- 使用 `javap -verbose`命令分析一个字节码文件时，将会分析该字节码文件的魔数，版本号，常量池，类信息，类的构造方法，类中的方法信息，类变量与成员变量的信息。

- Class 字节码中有两种数据类型：

  - 字节数据直接量（无符号数）：这是基本的数据类型。共细分为u1、u2、u4、u8四种，分别代表连续的1个字节、2个字节、4个字节、8个字节组成的无符号数据，可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成的字符串值。
  - 表/数组（无符号表）：表是由多个基本数据或其他表，按照既定顺序组成的大的数据集合。表都以 “_info" 结尾，表是有结构的，它的结构体表现在：组成表的成分所在的位置和顺序都是已经严格定义好的。**整个 class 文件本质上就是一张表**

- 无论是无符号数还是表，当需要描述同一类型但是数量不定的多个数据的时候，会使用一个前置的容量计数器加上若干连续的数据项的形式，该连续的数据称为集合；

- 字节码文件的结构图：

  ![字节码文件整体结构](%E5%AD%97%E8%8A%82%E7%A0%81.resource/20190823162350340.png)

  更加详细的结构为： Class 文件格式

  ![image-20191207111113479](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191207111113479.png)



### （三）字节码文件具体分析

#### 1. 魔数（magic）

- 所有的 .class 文件的前四个字节都是魔数，魔数值为固定值：0xCAFEBABE（咖啡宝贝）(前面 0x 表示十六进制)
- 用于确定这个文件是否为一个能被虚拟机接受的 Class 文件（相比文件后缀名更加安全）。

#### 2.版本号（version）

- 魔数后面 4 个字节是版本信息，前两个字节表示 minor_version（次版本号），后两个字节表示major_version（主版本号），因此这里值 `00 00 00 34 `对应十进制为 `00 00 00 52`，表示次版本号为 0，主版本号为 1.8（ 52对应 jdk 1.8）。**低版本的编译器编译的字节码可以在高版本的JVM下运行，反过来则不行**。

    ```java
    // 在终端中测试版本号进行验证
    C:\Users\gjx16>java -version
    // 主版本号：1.8，次版本号为：0，更新号为：221
    java version "1.8.0_221"
    ```

#### 3.常量池（constant pool）：

- 主版本号之后的就是常量池入口，**一个 java 类定义的很多信息都是由常量池来维护和描述的**，可以将常量池看作是 Class 文件的资源仓库，包括 java 类定义的方法和变量信息（包括类的和方法的变量），**常量池中主要存储两类常量：字面量和符号引用**。==常量池不是里面只有常量（即不变的量），可以有变量、方法等==

    - 字面量（Literal）：如文本字符串、java 中声明的 final 常量值等；
    - 符号引用（Symbolic References）：如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符（注：这里的描述符不是像源代码中的 public void 这样的，而是各种源代码中描述符的一种对应的映射，不同 JVM 中同样表示 public 含义不同修饰值的对应描述符是一致的）等。
      - 原因：因为使用 Javac 编译的时候不会连接，是 JVM 加载 Class 文件时候进行动态连接，因此如果**不经过运行期的转换，字段和方法的符号引用就找不到真正的内存地址，则无法被 JVM 使用**，因此需要当 JVM 运行的时候从常量池中获取对应的符号引用，然后在类创建或者运行时候解析获取到真正的内存地址。

- 常量池数量紧跟在主版本号后面，占据两个字节；常量池的整体结构：Java 类对应的常量池主要由**常量池数量**和**常量池数组**（又称为表结构）两部分共同构成，其中常量池数组紧跟在常量池数量之后。

    - 常量池数组与一般数组不同的是：常量池数组中元素的类型、结构都是不同的，长度当然也就不同，但是每一种元素的第一个数据都是一个u1类型标志位，占据一个字节，JVM在解析常量池时，就会根据这个u1类型的来获取对应的元素的具体类型。 值得注意的是，**常量池数组中元素的个数=常量池数-1**,（因为其中0暂时不使用）上面字节码 16 进制中常量池数目为：`00 18`表示 10 进制的 24，正好从上面代码反编译结果看出 `Constant pool`中一共 23 个元素。**常量池的容量计数器从 1 开始**

    - 为什么减一：目的是满足某些指向常量池的索引值的数据在特定的情况下需要表达不引用任何常量池的含义。根本原因在于索引为 0 也是一个常量，它是 JVM 的保留常量，它不位于常量表（常量池数组）中。这个常量就对应 null，所以**常量池的索引从 1 而非 0 开始**，其他接口索引集合、字段表集合、方法表集合等均从 0 开始。
      
    - 常量池中每一项常量都是一个表，下面是 14 种不同的表结构，后三种为 1.7 之后增加了支持动态语言调用：`CONSTANT_MethodHandle_info、CONSTANT_MethodType_info、CONSTANT_InvokeDynamic_info`，**14 种表中所有的表的第一位都是一个 u1 类型的标志位（tag），具体取值看下面对应的描述**；
      
      ![img](%E5%AD%97%E8%8A%82%E7%A0%81.resource/595137-20181219204338051-305022474.png)
      
      以 CONSTANT_UTF-8_info 型常量结构为例，bytes 中是一个长度为 length 字节的连续数据是一个使用 UTF-8 缩略编码表示的字符串，UTF-8 缩略编码和普通 UTF-8 编码的区别：`\u0001` 到 `\u007f`之间字符（相当于 1- 127 ASCII 码）的缩略编码使用一个字节表示，`\u0080` 到 `\u07ff`，使用 2 个字符，`\u0800` 到 `\uffff` 之间和普通编码一样使用三个字节表示。（该类型常量最大值为 65535，应为 Class 文件中方法、字段都是引用该类型常量，因此变量名和方法名最大长度Wie 64KB）
      

    测试：第一个常量为 ：`0A`表示十进制的 10，通过查表得到对应的是：`CONSTANT_InterfaceMethodref_info`然后向后查找两个字节：`00 04`（对应于4）表示指向声明方法的类描述符的索引项 ，在查找两个字节`00 14`（对应于 20）表示指向名称即类型描述符的索引项；至此这五个字节：`0A 00 04 00 14`就描述了常量池中的第一个常量；从反编译结果可以看出：` #1 = Methodref    #4.#20  ` 是正确的
        
    第二个常量为：`09`对应于 `Fieldref`，后面四个字节对应的索引分别指向十进制的 3 和 21；

    ​         。。。其他的分析方法同上；

    ​        针对：`01 00 01 61`，因为是 1所以表示是：`CONSTANT_utf8_info`，后面表示 utf8编码的长度为两个字节，该两个字节值对应十进制为：1，所以真正的内容长度就是 1 个字节，向后查找一个字节为：`61`对应十进制的 `a`；反编译结果比较：`   #5 = Utf8    a`

- 在JVM规范中，**每个变量/字段都有描述信息，描述信息主要的作用是描述字段的数据类型，方法的参数列表（包括数量、类型和顺序）与返回值**。

    - 根据描述符规则，**基本数据类型和代表无返回值的 void 类型都用一个大写字符来表示，而对象类型使用字符 `L+对象的全限定名称来表示（用 `/`标识）`**，这样主要为了压缩字节码文件的体积。

        - 基本数据类型：`B-byte，C-char，D-double，F-float，I-int，J-long，S-short，Z-boolean，V-void，L-对象类型`
        - 对象类型：如字符串对应：`Ljava/lang/String;`

    - 对于数组类型来说，每一个维度使用一个前置的`[` 来表示，如`int[]`表示为`[I` ，`String[][]`被记录为`[[Ljava/lang/String;`

    - 用描述符描述方法的时候，**用先参数列表后返回值的方式来描述**(方法名是作为一个常量放在常量池中的)。参数列表按照参数的严格顺序放在一组`()`之内，如方法`String getNameByID(int id ,String name)` 对应于：
        `(I,Ljava/lang/String;)Ljava/lang/String;`

        

    #### 4.访问标志信息（Access Flags）

    该标志用于识别一些类或者接口层次的访问信息，访问标志信息包括了该 class 文件是类还是接口，是否被定义成 public，是否是 abstract，如果是类，是否被定义成 final 等信息。
    
    ![img](%E5%AD%97%E8%8A%82%E7%A0%81.resource/4179925-1930eb74c76225e3.webp)
    这里 16 进制为：`00 21` 是 0x0020 和 0x0001 的并集，表示 ACC_PUBLIC 和 ACC_SUPER  两标志位为真，其他为假。
`0x0002`:private

**类、父类、接口都是索引**，索引的含义是指对应真正的值存储在常量池中； 类索引（确定该类的全限定名）和父类索引（确定该类的父类全限定名，除了 Object 类其它类该项均不为 0）都是一个 u2 类型的数据，接口索引集合（描述该类继承了哪些接口）是一组 u2 类型的数据的集合，**Class 文件中由这三项数据来确定这个类的继承关系**。
    
类、父类索引使用的两个 u2 类型的索引值表示，它们各自指向一个类型为 `CONSTANT_Class_info`的类描述符常量，通过该索引值可以找到定义在 `CONSTANT_Class_info` 类型的常量中的全限定名字符串。
    
#### 5.类名称（class Name）

占两个字节，对应：`00 03`这是一个索引，指向常量池中的一个常量，得到：` #3 = Class              #22   // com/gjxaiou/bytecode/MyTest1`
    
#### 6.父类名称（superClass）

对应：`00 04`,得到：` #4 = Class       #23     // java/lang/Object`
    
#### 7.接口（interface）

因为根据上面图片看出接口由两部分组成：接口计数器（表示索引表的容量）和接口名，分别都占两个字节，这里接口个数为：`00 00`，说明没有实现接口，然后接口索引表就不再出现（只有接口个数 >= 1，后面才会出现）
    
#### 8.字段表（Fields）

字段表用于描述类和接口中声明的变量。这里的字段包含了类级别变量和实例（成员）变量，但是不包括方法内部声明的局部变量。字段的修饰符在上面的访问修饰符（access flags）中。
    

**字段表的结构为**

| 类型           | 名称             | 数量             | 含义                                 |
| -------------- | ---------------- | ---------------- | ------------------------------------ |
| u2             | access_flags     | 1                | 字段访问标识                         |
| u2             | name_index       | 1                | 字段名称索引项（代表字段的简单名称） |
| u2             | descriptor_index | 1                | 字段描述索引项（字段和方法的修饰符） |
| u2             | attributes_count | 1                | 属性表计数器                         |
| attribute_info | attributes       | attributes_count | 属性表                               |



   字段修饰符（access_flags），也是一个 u2 的数据类型
![image-20191217105756411](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191217105756411.png)
    
成员变量：也是分成两部分，第一部分为：成员变量个数，值为：`00 01`表示只有一个字段，接下来两个字节`00 02`构成 `access_flags`，表示 private，然后就是另个字段`00 05`表示名字的索引:`#5 = Utf8      a`，然后后面连个字节`00 06`表示描述符索引：`#6 = Utf8   I`表示 int 类型，然后后面两个字节为 attributes_count（attribute 属性包含值不是固定的，可有可无），值为：`00 00`结果为0 ，则后面的 `attributes`也就没有了，至此该字段部分描述结束；
    

- 字段表集合中不会列出从超类或者父接口中继承而来的字段，但是可能列出原本 Java 代码中不存在的字段，例如内部类为了保持对外部类的访问性，会自动添加指向外部类实例的字段。==待验证==
- Java 中字段无法重载，但是对于字节码，如果两个同名字段的描述符不一致则认为是合法的。

**注：补充区分简单名称、描述符、全限定名**

- 简单名称：没有类型和参数修饰的方法或者字段名称，例如 MyTest 类中的 gc() 方法和 m 字段的简单名称为：`gc` 和 `m`;

- 类的全限定名：`com/gjxaiou/MyTest1`，为了区分多个全限定名，最后加上 `;` 表示该全限定名结束。

- 类全名：`com.gjxaiou.MyTest1`

- 方法和字段的描述符：用于描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值；描述符规则见上。

#### 9.方法表（Methods）

- 方法的属性结构：方法数量和方法表

  下面是**方法表**的结构

  | 类型           | 名称             | 数量             |
  | -------------- | ---------------- | ---------------- |
  | u2             | access_flags     | 1                |
  | u2             | name_index       | 1                |
  | u2             | descriptor_index | 1                |
  | u2             | attributes_count | 1                |
  | attribute_info | attributes       | attributes_count |

方法表的访问标志

![image-20191217113109001](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191217113109001.png)

**方法中的 Java 代码，进过编译器编译成字节码指令之后，存放在方法属性表集合中的 Code  属性中**。

**如果父类方法没有在子类中被重写（Override），则方法表集合中就不会有来自父类的方法信息**；但是可能会有编译器自动添加的方法：类构造器 `<clinit>` 方法和实例构造器 `<init>` 方法；

Java 中要重载一个方法，首先需要与原方法拥有相同的简单名称，同时和原方法的特征签名不同，**特征签名**就是一个方法中各个参数在常量池中的字段符号引用的集合，因为返回值不在特征签名中，所以不能讲返回值作为重载的依据。（Class 文件中的特征签名包含更广，所以两个方法相同的名称和特征签名，但是返回值不同（即只要描述符不是完全一致即可）也可以共存于同一个 Class 文件中）。

Java 代码中的方法特征签名包括方法名称、参数顺序和参数类型，字节码的特征签名还包括方法的返回值和受查异常表。



分析：首先是前面两个字节 `00 03 `表示方法的数量（这里因为编译器帮助我们生成了一个默认无参的构造方法，所以一共三个）；

接着后面就是真正的方法表内容：首先两个字节为`00 01`表示 Access_flags，对应就是 ：`public`，然后后面的 name_index 和 descriptor_index 都是对于常量池的引用，他们值分别为：`00 07` 和 `00 08`，分别对应于：` #7 = Utf8  <init>` 和`#8 = Utf8  ()V` 分别为方法名和方法的描述符；

### 属性表集合

属性表集合存在于 Class 文件、字段表、方法表中；下面是 JVM 规范中预定义的属性

![img](https://raw.githubusercontent.com/xiedacon/notes-JVM/master/images/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%9E%E6%80%A7.png)

然后属性个数为：`00 01`，表示有一个属性，对应于一个属性表（结构见下面的方法的属性结构表），首先下面的两个字节`00 09`，表示属性值的索引，对应值为：`#9 = Utf8   Code`，其中 Code 表示该方法的执行代码；然后后面四个字节`00 00 00 38`表示长度为 56,后面56个字节为具体的 Code 结构(Code 结构见下)，具体的方法体是以助记符的形式显示出来的，接下来挨个分析即可；

- 方法中的每个属性（attribute）都是一个 attribute_info 结构:
  - JVM预定义了部分attribute（见上），但是编译器自己也可以实现自己的 attribute 写入 class 文件里，供运行时使用；
  - 每一个属性的名称需要从常量池中引用一个 `CONSTANT_Utf8_info` 类型的常量来表示，属性的值的结构可以完全自定义（使用一个 u4 的长度属性来说明属性值所占用的位数即可）。
- 不同的 attribute 通过 attribute_name_index 来区分。
  - 属性表（attribute_info）格式:

```java
attribute_info{
  u2  attribute_name_index;
  u4  attribute_length;
  u1  info[attribute_length];
}
```

重点注意code_length的为：`00 00 00 0A`即为 10，即表示后面这十个字节代表了这个方法真正执行的内容：`2A B7 00 01 2A 04 B5 00 02 B1`对应使用 JClasslib 的值为：

![image-20191207145527272](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191207145527272.png)

这里之所以可以每个 16进制可以和助记符进行对应，是因为以及设置好了对应的映射，在工具中点击该助记符就可以查看（Java Virtual Machine Specification中），下面仅仅是一个实例，其他的可以自己点开，当然有的带参数有的不带参数，如果带参数则后面两字节就是参数对应常量池中的引用； 

![image-20191207150031184](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191207150031184.png)


​    

- attribute_name_index值为 code
  
    - Code的作用是保存该方法的结构所对应的字节码
    
    - **Code 的结构**为：
      
        ![Code属性表的结构](%E5%AD%97%E8%8A%82%E7%A0%81.resource/Code%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png)
        
    - attribute_length：表示 attribute 所包含的字节数，不包含 attribute_name_index 和 attribute_length，就是 arrtibute_length 字节后面的 attribute_length 长度表示方法真正执行的代码的指令；
    
    - max_stacks：表示这个方法运行的任何时刻所能达到的操作数栈的最大深度，这里为：`00 02`
    
    - max_locals：表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量，这里为：`00 01`
    
    - code_length：表示该方法所包含的字节码的字节数以及具体的指令码。具体的字节码是指该方法被调用时，虚拟机所执行的字节码，这里为：`00 00 00 0A`即为 10；
    
    - exception_table：存放处理异常的信息，每个exception_table表，是由start_pc、end_pc、hangder_pc、catch_type组成，这里为：`00 00`
    
        - start_pc、end_pc：表示在code数组中从start_pc到end_pc（包含start_pc，不包含end_pc）的指令抛出的异常会由这个表项来处理
        - hangder_pc：表示处理异常的代码的开始处。
        - catch_type：表示会被处理的异常类型，它指向常量池中的一个异常类。当catch_type=0时，表示处理所有的异常。
    
    - attributes_count：该方法属性数目，该属性不是指成员变量一类的；这里是：`00 02`表示两个属性，接下来两个字节为`00 0A `为索引，对应常量池中的：` #10 = Utf8     LineNumberTable`这里的行号表表示字节码中的行号和源代码中行号的对应关系；
    
        LineNumbeTable_attribute 结构为：
    
        ```java
        LineNumberTable_attribute {
            u2 attribute_name_index;
            u4 attribute_length;
            u2 line_number_table_length;
            {   u2 start_pc;
                u2 line_number;	
            } line_number_table[line_number_table_length];
        }
        ```
    
    这个属性表示code数组中，字节码与java代码行数之间的关系，可以在调试的时候定位代码执行的行数。就是执行的是字节码，出错怎么找到对应的源代码的行号呢；
    
    解析：接下来是4个字节的表示该属性的长度`00 00 00 0A`表示该属性占 10 个字节，即接下来的 10 个字节`00 02 00 00 00 03 04 00 04`表示真正的 LineNumbe 信息，十个字节中前两个字节表示有几对映射关系，这里是：`00 02`两队映射，前面四个字节`00 00 00 03`表示字节码的偏移量为0 映射到源代码偏移量为3，下面四个同样；
    
    ![image-20191207152447316](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191207152447316.png)
    
    然后就是第二个属性，值为`00 0B`表示`#11 = Utf8   LocalVariableTable`，局部变量表结构和上面结构类似；首先长度为：`00 00 00 0c`为 12 ，然后首先是局部变量的个数`00 01`，然后是局部变量的开始位置：`00 00 `，然后是局部变量的结束位置：`00 0A`，然后是局部变量的位置：`00`，然后是局部变量对应常量池中的映射`0C`，即为`#12 = Utf8   this` 所以这里只有一个局部变量即为本身的 this，接下来是局部变量的描述：`00 0D`，即`  #13 = Utf8   Lcom/gjxaiou/bytecode/MyTest1;`最后两个字节是校验可以不看；
    
    局部变量表结构为：描述栈中局部变量表中的变量与Java源码中定义的变量之间的关系。
    
    ```java
    LocalVariableTable_attribute {
        u2 attribute_name_index;
        u4 attribute_length;
        u2 local_variable_table_length;
        {   u2 start_pc;
            u2 length;
            u2 name_index;
            u2 descriptor_index;
            u2 index;
        } local_variable_table[local_variable_table_length];
    }
    ```
    
    
    ​    
    
    ![image-20191207153409732](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191207153409732.png)
    
    **为什么会有 This**：对于 Java 中任意一个非静态方法，至少会有一个局部变量，该局部变量即为 this；Java 中每一个方法中都可以访问this，该this 表示对当前方法的引用，作为字节码角度，该 this 是作为方法的第一个参数传递进来的，这里编译器在编译过程中会隐式的传递进来。
    
    - LocalVariableTable ：结构类似于 LineNumbeTable_attribute
        对于Java中的任何一个非静态方法，至少会有一个局部变量，就是this。
    
- 最后一部分信息：Attributes，表示归属当前字节码文件的信息，属性个数为：`00 01`，属性名字索引：`00 12`，对应于` #18 = Utf8    SourceFile`, 接下来是占用字节，表示 SourceFile 属性占用`00 02`字节，这里也就是接下来的最后连个字节：`00 13`对应于：` #19 = Utf8    MyTest1.java`
  
    - 字节码查看工具：jclasslib
        http://github.com/ingokegel/jclasslib，然后 view ->show bytecode by jclasslib
    
- 测试2 -------自己反编译分析MyTest2.class
    static变量会导致出现static代码块

```java
package com.gjxaiou.bytecode;

public class MyTest2 {
    String str = "Welcome";
    private int x = 5;
    public static Integer in = 5;

    public static void main(String[] args) {
        MyTest2 myTest2 = new MyTest2();
        myTest2.setX(8);
        in = 20;
    }
// 当 synchronized 修饰一个实例方法时候表示给当前对象 this 加锁
    private synchronized void setX(int x) {
        this.x = x;
    }
}
```

反编译之后结果，因为这里有私有的方法（或者变量）需要增加参数值才能在字节码文件中显示结果：`javap - verbose -p`

```java
E:\Program\Java\JVM\DemoByMyself\out\production\DemoByMyself\com\gjxaiou\bytecode>javap -verbose -p MyTest2
警告: 二进制文件MyTest2包含com.gjxaiou.bytecode.MyTest2
Classfile /E:/Program/Java/JVM/DemoByMyself/out/production/DemoByMyself/com/gjxaiou/bytecode/MyTest2.class
  Last modified 2019-12-7; size 838 bytes
  MD5 checksum 6c83f559cb7f10ca47860e58f3a6a485
  Compiled from "MyTest2.java"
public class com.gjxaiou.bytecode.MyTest2
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #10.#34        // java/lang/Object."<init>":()V
   #2 = String             #35            // Welcome
   #3 = Fieldref           #5.#36         // com/gjxaiou/bytecode/MyTest2.str:Ljava/lang/String;
   #4 = Fieldref           #5.#37         // com/gjxaiou/bytecode/MyTest2.x:I
   #5 = Class              #38            // com/gjxaiou/bytecode/MyTest2
   #6 = Methodref          #5.#34         // com/gjxaiou/bytecode/MyTest2."<init>":()V
   #7 = Methodref          #5.#39         // com/gjxaiou/bytecode/MyTest2.setX:(I)V
   #8 = Methodref          #40.#41        // java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
   #9 = Fieldref           #5.#42         // com/gjxaiou/bytecode/MyTest2.in:Ljava/lang/Integer;
  #10 = Class              #43            // java/lang/Object
  #11 = Utf8               str
  #12 = Utf8               Ljava/lang/String;
  #13 = Utf8               x
  #14 = Utf8               I
  #15 = Utf8               in
  #16 = Utf8               Ljava/lang/Integer;
  #17 = Utf8               <init>
  #18 = Utf8               ()V
  #19 = Utf8               Code
  #20 = Utf8               LineNumberTable
  #21 = Utf8               LocalVariableTable
  #22 = Utf8               this
  #23 = Utf8               Lcom/gjxaiou/bytecode/MyTest2;
  #24 = Utf8               main
  #25 = Utf8               ([Ljava/lang/String;)V
  #26 = Utf8               args
  #27 = Utf8               [Ljava/lang/String;
  #28 = Utf8               myTest2
  #29 = Utf8               setX
  #30 = Utf8               (I)V
  #31 = Utf8               <clinit>
  #32 = Utf8               SourceFile
  #33 = Utf8               MyTest2.java
  #34 = NameAndType        #17:#18        // "<init>":()V
  #35 = Utf8               Welcome
  #36 = NameAndType        #11:#12        // str:Ljava/lang/String;
  #37 = NameAndType        #13:#14        // x:I
  #38 = Utf8               com/gjxaiou/bytecode/MyTest2
  #39 = NameAndType        #29:#30        // setX:(I)V
  #40 = Class              #44            // java/lang/Integer
  #41 = NameAndType        #45:#46        // valueOf:(I)Ljava/lang/Integer;
  #42 = NameAndType        #15:#16        // in:Ljava/lang/Integer;
  #43 = Utf8               java/lang/Object
  #44 = Utf8               java/lang/Integer
  #45 = Utf8               valueOf
  #46 = Utf8               (I)Ljava/lang/Integer;
{
  java.lang.String str;
    descriptor: Ljava/lang/String;
    flags:

  private int x;
    descriptor: I
    flags: ACC_PRIVATE

  public static java.lang.Integer in;
    descriptor: Ljava/lang/Integer;
    flags: ACC_PUBLIC, ACC_STATIC

  public com.gjxaiou.bytecode.MyTest2();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: ldc           #2                  // String Welcome
         7: putfield      #3                  // Field str:Ljava/lang/String;
        10: aload_0
        11: iconst_5
        12: putfield      #4                  // Field x:I
        15: return
      LineNumberTable:
        line 3: 0
        line 4: 4
        line 5: 10
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      16     0  this   Lcom/gjxaiou/bytecode/MyTest2;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: new           #5                  // class com/gjxaiou/bytecode/MyTest2
         3: dup
         4: invokespecial #6                  // Method "<init>":()V
         7: astore_1
         8: aload_1
         9: bipush        8
        11: invokespecial #7                  // Method setX:(I)V
        14: bipush        20
        16: invokestatic  #8                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
        19: putstatic     #9                  // Field in:Ljava/lang/Integer;
        22: return
      LineNumberTable:
        line 9: 0
        line 10: 8
        line 11: 14
        line 12: 22
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      23     0  args   [Ljava/lang/String;
            8      15     1 myTest2   Lcom/gjxaiou/bytecode/MyTest2;

  private synchronized void setX(int);
    descriptor: (I)V
    flags: ACC_PRIVATE, ACC_SYNCHRONIZED
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: iload_1
         2: putfield      #4                  // Field x:I
         5: return
      LineNumberTable:
        line 15: 0
        line 16: 5
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       6     0  this   Lcom/gjxaiou/bytecode/MyTest2;
            0       6     1     x   I

  static {};
    descriptor: ()V
    flags: ACC_STATIC
    Code:
      stack=1, locals=0, args_size=0
         0: iconst_5
         1: invokestatic  #8                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
         4: putstatic     #9                  // Field in:Ljava/lang/Integer;
         7: return
      LineNumberTable:
        line 6: 0
}
SourceFile: "MyTest2.java"

```

只要代码中有静态变量，则 Fields  中肯定存在静态方法`<clinit>`，是编译器自动生成的；

**构造方法**

![image-20191207170539362](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191207170539362.png)

可以看出`    String str = "Welcome";` 和`private int x = 5;` 的赋值是在编译器为我们生成的构造方法中执行的，**就是会将非静态的赋值操作放入构造方法中**；即使我们提供了构造方法，但是字节码中对应的赋值任然没有变化，还是在构造方法中进行赋值。如果有几个不同的构造方法，相当于将上面两个赋值语句分别放入构造方法里面的首位，保证无论执行哪一个构造方法都会对两个值进行初始化（两个赋值语句与构造方法相对位置无关，两个赋值语句之间的相对关系有关）。

**静态的成员变量的赋值是在 `<clinit>` 方法中完成的**，包括如果有静态代码块，所有的静态相关的都会放在同一个 `<clinit>`方法中；

![image-20191207180248501](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191207180248501.png)

## 异常处理对应的字节码文件分析

异常的结构为：

```java
Exceptions_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u2 number_of_exceptions;
    u2 exception_index_table[number_of_exceptions];
}
```



- 测试3

```java
package com.gjxaiou.bytecode;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;

public class MyTest3 {
    public void test() {
        try {
            InputStream is = new FileInputStream("test.txt");
            ServerSocket serverSocket = new ServerSocket(9999);
            serverSocket.accept();
        } catch (FileNotFoundException e) {

        } catch (IOException e) {

        } catch (Exception e) {

        } finally {
            System.out.println("finally");
        }
    }
}
```

对应的反编译结果：

```java
E:\Program\Java\JVM\DemoByMyself\out\production\DemoByMyself\com\gjxaiou\bytecode>javap -verbose MyTest3
警告: 二进制文件MyTest3包含com.gjxaiou.bytecode.MyTest3
Classfile /E:/Program/Java/JVM/DemoByMyself/out/production/DemoByMyself/com/gjxaiou/bytecode/MyTest3.class
  Last modified 2019-12-7; size 1064 bytes
  MD5 checksum 3861a6dfc9c6a41fbb9d9e5ba56ae0b0
  Compiled from "MyTest3.java"
public class com.gjxaiou.bytecode.MyTest3
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #15.#35        // java/lang/Object."<init>":()V
   #2 = Class              #36            // java/io/FileInputStream
   #3 = String             #37            // test.txt
   #4 = Methodref          #2.#38         // java/io/FileInputStream."<init>":(Ljava/lang/String;)V
   #5 = Class              #39            // java/net/ServerSocket
   #6 = Methodref          #5.#40         // java/net/ServerSocket."<init>":(I)V
   #7 = Methodref          #5.#41         // java/net/ServerSocket.accept:()Ljava/net/Socket;
   #8 = Fieldref           #42.#43        // java/lang/System.out:Ljava/io/PrintStream;
   #9 = String             #44            // finally
  #10 = Methodref          #45.#46        // java/io/PrintStream.println:(Ljava/lang/String;)V
  #11 = Class              #47            // java/io/FileNotFoundException
  #12 = Class              #48            // java/io/IOException
  #13 = Class              #49            // java/lang/Exception
  #14 = Class              #50            // com/gjxaiou/bytecode/MyTest3
  #15 = Class              #51            // java/lang/Object
  #16 = Utf8               <init>
  #17 = Utf8               ()V
  #18 = Utf8               Code
  #19 = Utf8               LineNumberTable
  #20 = Utf8               LocalVariableTable
  #21 = Utf8               this
  #22 = Utf8               Lcom/gjxaiou/bytecode/MyTest3;
  #23 = Utf8               test
  #24 = Utf8               is
  #25 = Utf8               Ljava/io/InputStream;
  #26 = Utf8               serverSocket
  #27 = Utf8               Ljava/net/ServerSocket;
  #28 = Utf8               StackMapTable
  #29 = Class              #47            // java/io/FileNotFoundException
  #30 = Class              #48            // java/io/IOException
  #31 = Class              #49            // java/lang/Exception
  #32 = Class              #52            // java/lang/Throwable
  #33 = Utf8               SourceFile
  #34 = Utf8               MyTest3.java
  #35 = NameAndType        #16:#17        // "<init>":()V
  #36 = Utf8               java/io/FileInputStream
  #37 = Utf8               test.txt
  #38 = NameAndType        #16:#53        // "<init>":(Ljava/lang/String;)V
  #39 = Utf8               java/net/ServerSocket
  #40 = NameAndType        #16:#54        // "<init>":(I)V
  #41 = NameAndType        #55:#56        // accept:()Ljava/net/Socket;
  #42 = Class              #57            // java/lang/System
  #43 = NameAndType        #58:#59        // out:Ljava/io/PrintStream;
  #44 = Utf8               finally
  #45 = Class              #60            // java/io/PrintStream
  #46 = NameAndType        #61:#53        // println:(Ljava/lang/String;)V
  #47 = Utf8               java/io/FileNotFoundException
  #48 = Utf8               java/io/IOException
  #49 = Utf8               java/lang/Exception
  #50 = Utf8               com/gjxaiou/bytecode/MyTest3
  #51 = Utf8               java/lang/Object
  #52 = Utf8               java/lang/Throwable
  #53 = Utf8               (Ljava/lang/String;)V
  #54 = Utf8               (I)V
  #55 = Utf8               accept
  #56 = Utf8               ()Ljava/net/Socket;
  #57 = Utf8               java/lang/System
  #58 = Utf8               out
  #59 = Utf8               Ljava/io/PrintStream;
  #60 = Utf8               java/io/PrintStream
  #61 = Utf8               println
{
  public com.gjxaiou.bytecode.MyTest3();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 9: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/gjxaiou/bytecode/MyTest3;

  public void test();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      // 对于 Java 类中的每一个实例方法（非 static 方法），其在编译后所生成的字节码中，方法参数的数量总是比源代码中方法参数的数量多一个（即为 this），它位于方法的第一个参数位置处。这样我们就可以在 Java 的实例方法中使用 this 来访问当前对象的属性以及其他方法；
     // 这个操作时在编译期间完成的，即在 Javac 编译器在编译的时候将对 this 的访问转化为对一个普通实例方法的访问，接下来在运行期间，由 JVM 在实例方法时候，自动的向实例方法传入该 this 参数，所以在实例方法的局部变量表中，至少会有一个执行当前对象的局部变量。
      	// Locals = 4:this/is/serverSocket/ex(这个 ex 为三个其中之一，因为 catch 只能执行一个)，这里表示最多为 4 个，因为 catch 方法可能不执行；
      stack=3, locals=4, args_size=1
         // 创建对象，这里就是创建了一个 FileInputStream 对象
         0: new           #2                  // class java/io/FileInputStream
         // dup:将操作数栈最顶层数进行复制，相当于压栈
         3: dup
         // ldc：从运行期的常量池中推一个 item，就是将常量池中的 test.txt 推进去，使其能构造出该对象
         4: ldc           #3                  // String test.txt
         // 调用父类的相应构造方法    
         6: invokespecial #4                  // Method java/io/FileInputStream."<init>":(Ljava/lang/String;)V
         // 将应用存储到一个局部变量中，就是将 FileInputStream 创建处理实例的引用存储到局部变量 is 中
         9: astore_1
         // 以上5行对应于源代码中的 InputStream is = new FileInputStream("test.txt");    
        10: new           #5                  // class java/net/ServerSocket
        13: dup
        14: sipush        9999
        17: invokespecial #6                  // Method java/net/ServerSocket."<init>":(I)V
        20: astore_2
        21: aload_2
        22: invokevirtual #7                  // Method java/net/ServerSocket.accept:()Ljava/net/Socket; 
        25: pop
        26: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;
        29: ldc           #9                  // String finally
        31: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         // 因为可能报错，因此执行的顺序在运行期才能确定，在编译期只能使用 goto 语句在做可能的跳转
        34: goto          84
        // 将抛出的异常引用赋值给 ex 对象
        37: astore_1
        38: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;
        41: ldc           #9                  // String finally
        43: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         // catch 中执行之后跳转到 84，即 return  
        46: goto          84
        49: astore_1
        50: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;
        53: ldc           #9                  // String finally
        55: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        58: goto          84
        61: astore_1
        62: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;
        65: ldc           #9                  // String finally
        67: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        70: goto          84
        73: astore_3
        74: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;
        77: ldc           #9                  // String finally
        79: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        82: aload_3
        83: athrow
        84: return
      Exception table:
         from    to  target type
             0    26    37   Class java/io/FileNotFoundException
             0    26    49   Class java/io/IOException
             0    26    61   Class java/lang/Exception
             0    26    73   any
      LineNumberTable:
        line 12: 0
        line 13: 10
        line 14: 21
        line 22: 26
        line 23: 34
        line 15: 37
        line 22: 38
        line 23: 46
        line 17: 49
        line 22: 50
        line 23: 58
        line 19: 61
        line 22: 62
        line 23: 70
        line 22: 73
        line 23: 82
        line 24: 84
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
           10      16     1    is   Ljava/io/InputStream;
           21       5     2 serverSocket   Ljava/net/ServerSocket;
            0      85     0  this   Lcom/gjxaiou/bytecode/MyTest3;
      StackMapTable: number_of_entries = 5
        frame_type = 101 /* same_locals_1_stack_item */
          stack = [ class java/io/FileNotFoundException ]
        frame_type = 75 /* same_locals_1_stack_item */
          stack = [ class java/io/IOException ]
        frame_type = 75 /* same_locals_1_stack_item */
          stack = [ class java/lang/Exception ]
        frame_type = 75 /* same_locals_1_stack_item */
          stack = [ class java/lang/Throwable ]
        frame_type = 10 /* same */
}
SourceFile: "MyTest3.java"

```

- exception_table：存放处理异常的信息，每个exception_table表，是由start_pc、end_pc、hangder_pc、catch_type组成，这里为：`00 00`
    - start_pc、end_pc：表示在code数组中从start_pc到end_pc（包含start_pc，不包含end_pc）的指令抛出的异常会由这个表项（hangder_pc）来处理
    - hangder_pc：表示处理异常的代码的开始处。
    - catch_type：表示会被处理的异常类型，它指向常量池中的一个异常类。当catch_type=0时，表示处理所有的异常。

    ![image-20191207184820512](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191207184820512.png)

- Java字节码对于异常的处理方式：
  
    - 统一采用异常表的方式来对异常进行处理；
    
    - 在jdk1.4.2之前的版本中，并不是使用异常表的方式对异常进行处理的，而是采用特定的指令方式；
    
    - 当异常处理存在 finally 语句块时，现代化的 JVM 采取的处理方式是将 finally 语句内的字节码拼接到每个catch 语句块后面。也就是说，程序中存在多少个 catch，就会在每一个 catch 块后面重复多少个 finally 语句块，也就是存在多少个 finally 块的内容。
    
        ![image-20191207190130275](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191207190130275.png)
    
    **如果将异常抛出，对应的字节码为**
    
    源代码上区别：`public void test()  throws FileNotFoundException, NullPointerException{`
    
    对应的字节码：
    
    ![image-20191207190923625](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191207190923625.png)
    
    ## 字节码执行过程
    
- 栈帧（stack frame）：
  
    - 是用于帮助虚拟机执行方法调用和方法执行的数据结构
    - 栈帧归属于一个一个的线程，每个线程只会拥有自己独有的栈帧的结构，因此对于栈帧不存在并发和同步调用问题；
    - 栈帧本身是一种数据结构，封装了方法的局部变量表，动态链接信息，方法的返回地址以及操作数栈等信息。
    
- 符号引用：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和虚拟机的布局无关。（在编译的时候一个每个java类都会被编译成一个class文件，但在编译的时候虚拟机并不知道所引用类的地址，多以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。）

- 直接引用：（1）直接指向目标的指针（指向对象，类变量和类方法的指针）（2）相对偏移量。（指向实例的变量，方法的指针）（3）一个间接定位到对象的句柄。

有些符号引用在加载阶段或者或是第一次使用时，转换为直接引用，这种转换叫做**静态解析**；另外一些符号引用则是在**每次运行期**转换为直接引用，这种转换叫做**动态链接**。这种动态链接体现了 Java 的多态性。

- 助记符：
    - invokeinterface：调用接口的方法，在**运行期决定**调用该接口的哪个对象的特定方法。
    - invokestatic：调用静态方法
    - invokespecial：调用私有方法， 构造方法（使用 `<init>`标识），父类的方法
    - invokevirtual：调用虚方法（语言层面上不存在该概念，字节码中存在），运行期动态查找的过程
    - invokedynamic：动态调用方法

- 测试4：测试 invokestatic

```java
public class MyTest4{
    public static void test(){
            System.out.println("static test");
    }
    public static void main(Stirng[] args){
        test();             //invokestatic
    }
}
```

对应的字节码文件

![image-20191207194449349](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191207194449349.png)



能被 invokestatic、invokespecial 两个指令调用的方法都是能在解析阶段就能唯一确定该方法的调用过程；就是下面中的静态静态解析四种场景

静态解析的四种场景：静态方法、父类方法、构造方法、私有方法（公有方法是可能被重写的，就存在多态的可能的）。以上四种方法称为非虚方法，在类加载阶段将符号引用转换为直接引用。



- 测试5：方法重载

```java
package com.gjxaiou.bytecode;


/**
 * 方法的静态分派。
 * Grandpa g1 = new Father();
 * 以上代码, g1的静态类型(声明的类型)是Grandpa,而g1的实际类型(真正指向的类型)是Father.
 * 我们可以得出这样一个结论:变量的静态类型是不会发生变化的,而变量的实际类型则是可以发生变化的(多态的一种体现)
 * 实际变量是在运行期方可确定
 */
class Grandpa {
}

class Father extends Grandpa {
}

class Son extends Father {
}

public class MyTest5 {
    //方法重载,是一种静态的行为,在调用方法时候，JVM唯一判断依据就是根据该方法本身接收的参数（声明的参数类型）来决定调用哪一个方法，编译期就可以完全确定
    public void test(Grandpa grandpa) {
        System.out.println("Grandpa");
    }

    public void test(Father father) {
        System.out.println("father");
    }

    public void test(Son son) {
        System.out.println("Son");
    }

    public static void main(String[] args) {
        MyTest5 myTest5 = new MyTest5();
        Grandpa g1 = new Father();
        Grandpa g2 = new Son();
        myTest5.test(g1);
        myTest5.test(g2);
    }
}
/**
 * output:
 * Grandpa
 * Grandpa
 */



```

![image-20191207201803199](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191207201803199.png)

对于方法重载：其可以在编译期就可以完全确定，因为虽然方法本身（test）进行了重载，但是调用方法本身的永远都是方法所在类的实例（myTest5），唯一变化的就是向方法中传入什么类型的参数而已；

对于方法重写：是一种动态信息，到底调用哪一个对象特定的方法是在运行期才能确定的；

- 测试6：方法重写

```java
package com.gjxaiou.bytecode;

/**
 * 方法的动态分派（运行期才能确定调用哪个方法）
 * 方法的动态分派涉及到一个重要概念:方法接收者（方法到底是由哪个对象来调用的）。
 *
 * invokevirtual 字节码指令的多态查找流程:
 * 首先到操作数的栈顶去寻找栈顶元素所指向的对象的实际类型（不是静态类型）；（这里就是 apple 类型）
 * 如果寻找到了与常量池中描述符和名称都相符的方法（这里就是在 APPle 类中找到一个与<com/gjxaiou/bytecode/Fruit
 * .test>方法的描述符和名称一样的方法），并且具备访问权限，就返回目标方法的直接引用（这里就是返回 Apple 中 test 方法的直接引用），流程结束；
 * 如果找不到，就按照继承关系从子类到父类的一层一层的使用上面的查找流程，一直能找到为止，如果找不到报错；
 *
 * 比较方法重载(overload)与方法重写(overwrite) ,我们可以得到这样一个结论:
 * 方法重载是静态的,是编译期行为;
 * 方法重写是动态的,是运行期行为。
 *
 * 下面就是三个 test 方法的符号引用虽然相同（都是 <com/gjxaiou/bytecode/Fruit.test>），但是在运行期转换成了不同的直接引用
 */
class Fruit {
    public void test() {
        System.out.println("Fruit");
    }
}

class Apple extends Fruit {
    @Override
    public void test() {
        System.out.println("Apple");
    }
}

class Orange extends Fruit {
    @Override
    public void test() {
        System.out.println("Orange");
    }
}

public class MyTest6 {
    public static void main(String[] args) {
        // new 的作用：首先为该对象在堆上开辟一个内存空间，然后执行其构造方法，最后将构造方法执行完后返回的针对在堆上所生成的对象的引用返回；
        /** new 关键字对应于字节码中的下面四个操作：
         *  0 new #2 <com/gjxaiou/bytecode/Apple> // 开辟内存空间并创建对象
         *  3 dup // 将引用的对象的值压入到栈顶
         *  4 invokespecial #3 <com/gjxaiou/bytecode/Apple.<init>>  // 调用对象的构造方法
         *  7 astore_1 // 将对象在堆上的引用返回赋给一个局部变量
         */
        Fruit apple = new Apple();
        Fruit orange = new Orange();

        // 16 aload_1：从局部变量中加载索引为 1 的引用，就是 apple
        apple.test();
        orange.test();

        apple = new Orange();
        apple.test();
        // 上面三个 test() 方法最终对应的字节码都是：invokevirtual #6 <com/gjxaiou/bytecode/Fruit.test>
    }
}
/** output:
 * Apple
 * Orange
 * Orange
 */
```

对应的 Class 文件

![image-20191207210522248](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191207210522248.png)

测试7：重载和重写

```java
package com.gjxaiou.bytecode;

import java.util.Date;

public class MyTest7 {
    public static void main(String[] args) {
        Animal animal = new Animal();
        Animal dog = new Dog();
        animal.test("hello");
        dog.test(new Date());
    }

}

class Animal {
    public void test(String str) {
        System.out.println("animal str");
    }

    public void test(Date date) {
        System.out.println("animal date");
    }
}

class Dog extends Animal {
    @Override
    public void test(String str) {
        System.out.println("dog str");
    }

    @Override
    public void test(Date date) {
        System.out.println("dog date");
    }
}
```

对应的 Class 结构

![image-20191207211547115](%E5%AD%97%E8%8A%82%E7%A0%81.resource/image-20191207211547115.png)

因为 JVM 要从堆栈数的最顶部进行搜索，所以如何优化：**使用虚方法表的索引来代替查找过程**

针对方法调用调用动态分配过程，虚拟机会在类的方法区建立一个虚方法表的数据结构（virtual method table，简称：vtable）

针对于接口的 invokeinterface 指令来说，虚拟机会建立一个叫做接口方法表的数据结构（interface method table，简称：itable）



应为上述都是运行期的概念，所以虚方法表中存储的是每一个方法真正的实际入口的调用地址，虚方法表中每一项就标识着这个特定方法的实际入口的调用地址，**如果子类没有重写父类的某个方法**，那么子类和父类中的该方法就是一样的，则子类针对从父类继承并且没有重写的方法在子类中该方法的入口地址就直接指向了父类中的这个特定的方法，而不是在子类中又复制了一遍（可以增加查找效率和减少内存占用空间）；

虚方法表一般在类加载的连接阶段完成的；

### 测试7：

```java
package com.poplar.bytecode;

/**
 * Created BY poplar ON 2019/12/4
 * 基于栈的解释器的执行过程概念模型
 */
public class BasicStackExecutionProcess {

    public int calc() {
        int a = 100;
        int b = 200;
        int c = 300;
        return (a + b) * c;

    /*
   public int calc();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=4, args_size=1
         0: bipush        100  执行地址偏移量为0 将100推送至栈顶
         2: istore_1          执行地址偏移量为2  将栈顶的100出栈并存放到第一个局部变量Slot中
         3: sipush        200
         6: istore_2
         7: sipush        300
        10: istore_3
        11: iload_1          执行地址偏移量为11 将局部变量中第一个Slot中的整型值复制到栈顶
        12: iload_2
        13: iadd            将栈顶的两个元素出栈并作整形加法，然后把结果重新入栈
        14: iload_3
        15: imul            将栈顶的两个元素出栈并作整形乘法，然后把结果重新入栈
        16: ireturn         结束方法并将栈顶的值返回给方法调用者
      LineNumberTable:
        line 10: 0
        line 11: 3
        line 12: 7
        line 13: 11
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      17     0  this   Lcom/poplar/bytecode/BasicStackExecutionProcess;
            3      14     1     a   I
            7      10     2     b   I
           11       6     3     c   I
     */
    }

    public static void main(String[] args) {
        BasicStackExecutionProcess process = new BasicStackExecutionProcess();
        int res = process.calc();
        System.out.println(res);
    }
}
```

### 动态分派：

```java
package com.poplar.bytecode;

/**
 * Created BY poplar ON 2019/12/4
 * 动态分派的演示与证明：
 * 在动态分派中虚拟机是如何知道要调用那个方法的？
 */
public class DynamicDispatch {

    static abstract class Human {
        public abstract void hello();
    }

    static class Man extends Human {
        @Override
        public void hello() {
            System.out.println("Hello Man");
        }
    }

    static class Woman extends Human {
        @Override
        public void hello() {
            System.out.println("Hello Woman");
        }
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woMan = new Woman();
        man.hello();
        woMan.hello();

        man = new Woman();
        man.hello();

    /*public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: new           #2                  // class main/java/com/poplar/bytecode/DynamicDispatch$Man
         3: dup
         4: invokespecial #3                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Man."<init>":()V
         7: astore_1
         8: new           #4                  // class main/java/com/poplar/bytecode/DynamicDispatch$Woman
        11: dup
        12: invokespecial #5                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Woman."<init>":()V
        15: astore_2
        16: aload_1 从局部变量加载一个引用 aload1是加载索引为1的引用（man），局部变量有三个（0：args; 1 :man ; 2 :woMan）
        17: invokevirtual #6                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Human.hello:()V
        20: aload_2 加载引用woMan
        21: invokevirtual #6                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Human.hello:()V
        24: new           #4                  // class main/java/com/poplar/bytecode/DynamicDispatch$Woman
        27: dup
        28: invokespecial #5                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Woman."<init>":()V
        31: astore_1
        32: aload_1
        33: invokevirtual #6                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Human.hello:()V
        36: return
      LineNumberTable:
        line 28: 0
        line 29: 8
        line 30: 16
        line 31: 20
        line 33: 24
        line 34: 32
        line 36: 36
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      37     0  args   [Ljava/lang/String;
            8      29     1   man   Lmain/java/com/poplar/bytecode/DynamicDispatch$Human;
           16      21     2 woMan   Lmain/java/com/poplar/bytecode/DynamicDispatch$Human;
    }
    invokevirtual 运行期执行的时候首先：
    找到操作数栈顶的第一个元素它所指向对象的实际类型，在这个类型里边，然后查找和常量里边Human的方法描述符和方法名称都一致的
    方法，如果在这个类型下，常量池里边找到了就会返回实际对象方法的直接引用。

    如果找不到，就会按照继承体系由下往上(Man–>Human–>Object)查找，查找匹配的方式就是
    上面描述的方式，一直找到位为止。如果一直找不到就会抛出异常。

    比较方法重载（overload）和方法重写（overwrite），我们可以得出这样的结论：
    方法重载是静态的，是编译器行为；方法重写是动态的，是运行期行为。
    ————————————————
    版权声明：本文为CSDN博主「魔鬼_」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
    原文链接：https://blog.csdn.net/wzq6578702/article/details/82712042
       */
    }
}
```

### 静态分派：

```java
package com.poplar.bytecode;

/**
 * Created BY poplar ON 2019/12/4
 * 静态分派的演示与证明：
 */
public class StaticDispatch {

    static abstract class Human {

    }

    static class Man extends Human {

    }

    static class Woman extends Human {

    }

    public void hello(Human param) {
        System.out.println("Hello Human");
    }

    public void hello(Man param) {
        System.out.println("Hello Man");
    }

    public void hello(Woman param) {
        System.out.println("Hello Woman");
    }

    public static void main(String[] args) {
        StaticDispatch dispatch = new StaticDispatch();
        /*Human man = new Man();
        Human woMan = new Woman();
        dispatch.hello(man);
        dispatch.hello(woMan);*/

        Human human = new Woman();
        human = new Man();
        dispatch.hello((Woman) human);
        dispatch.hello((Man) human);
        //java.lang.ClassCastException: main.java.com.poplar.bytecode.WoMan cannot be cast to main.java.com.poplar.bytecode.Man
    }
}
```

- 现代 JVM 在执行Java代码的时候,通常都会将解释执行与编译执行二者结合起来进行.

    - 解释执行：就是通过解释器来读取字节码,遇到相应的指令就去执行该指令；
    - 编译执行：就是通过即时编译器 (Just in Time,  JIT) 将字节码转换为本地机器码来执行；现代 JVM 会根据代码热点（执行频率）来生成目应的本地机器码。 在布尔德E马文项目

- 基于栈的指令集和基于寄存器的指令集之间的关系

    - JVM 执行指令时所采取的方式是基于栈的指令集。
- 基于栈的指令集主要有入栈和出栈两种；
    - 基于栈的指令集的优势在于它可以在不同平台之间的移植，而基于寄存器的指令集是与硬件架构紧密关联，无法做到可移植；

    - 基于栈的指令集的缺点在于完成相同的操作,指令集通常要比基于寄存器的指令集要多，基于栈的指令集是在内存中完成操作的，而基于寄存器的指令集是直接由CPU来执行的，它是在高速缓冲区中进行的，速度要快很多。虽然虚拟机可以采用一些优化手段（该一些高频的指令集映射到寄存器中），但总体来说，基于栈的指令集的执行速度要慢一些；
    
    - 基手栈的指令集的优势在于它可以在不同平台之间移植,而基于寄存器的指令集是与硬件架构累密关联的,无法做到可移植。
    
    示例：如果完后 2 -1 的操作，对应的基于栈的指令集操作
    
    ```java
    iconst_1  // 首先将减数 1 压入到栈顶
    iconst_2  // 然后将被减数 2 压入到栈顶
    isub      // 将栈顶和栈顶下面两个值弹出，然后执行相减的操作，并将运算结果压入到栈顶
    istore_0  // 将结果放入局部变量表的第 0 个位置
    ```
    
    如果对应寄存器的操作
    
    ```java
    首先使用 mov 将 2 放入寄存器
    然后使用 sub 调用减法操作，后面加上参数 1，最后将结果放入寄存器中
    ```
    
    

- 示例8：基于栈的指令集

    ```java
    package com.gjxaiou.bytecode;
    
    public class MyTest8 {
        public int myCalculate(){
            int a = 1;
            int b = 2;
            int c = 3;
            int d = 4;
            int result = (a + b - c) * d;
            return result;
        }
    }
    
    ```

    对上面的代码进行反编译之后，其中 myCalculate() 方法反编译结果为：

    ```java
     public int myCalculate();
        descriptor: ()I
        flags: ACC_PUBLIC
        Code:
    // 栈的最大深度为 2，即栈中最多容纳 2 个元素；最大的局部变量为 6，参数数量为 1，即为 this
          stack=2, locals=6, args_size=1
             // 将常量数（-1 ~ 5）这里为 1 推送到操作数栈
             0: iconst_1
             // 将操作数栈顶元素弹出，同时将局部变量表中索引 istore 后面参数位置的值设置为弹出值
                 // 局部变量表 0 号位置为 this
             1: istore_1
             2: iconst_2
             3: istore_2
             4: iconst_3
             5: istore_3
             6: iconst_4
             // 含义同上，但是因为只有三个值，后面 4 即为局部变量表索引    
             7: istore        4
             // 将局部变量表中索引位置为 1 的变量值推送到栈顶    
             9: iload_1
            10: iload_2
            // 将操作数栈顶和栈顶下面两个数弹出相加并将结果压入栈中    
            11: iadd
            12: iload_3
            13: isub
            14: iload         4
            16: imul
            17: istore        5
            19: iload         5
            21: ireturn
    ```

    

**动态代理**

视频  57- 58，代码见下，分析么有看完

```java
package com.gjxaiou.bytecode;

/**
 * 被代理的接口
 */
public interface Subject {
    void request();
}
```

```java
package com.gjxaiou.bytecode;

public class RealSubject  implements Subject{
    @Override
    public void request() {
        System.out.println("From real subject");
    }
}

```

```java
package com.gjxaiou.bytecode;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class DynamicSubject implements InvocationHandler {
    // 创建一个真实对象
    private Object sub;
    // 将真实对象作为参数传入构造方法
    public DynamicSubject(Object obj){
        this.sub = obj;
    }

    // 对真实对象的调用都会通过动态代理中 invoke 方法来执行
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("before calling: " + method);
        // 对于真正目标方法的调用
        method.invoke(this.sub, args);
        System.out.println("after calling: " + method);
        return null;
    }
}

```



```java
package com.gjxaiou.bytecode;

import java.lang.reflect.Proxy;

public class Client {
    public static void main(String[] args) {
        RealSubject rs = new RealSubject();
        DynamicSubject ds = new DynamicSubject(rs);
        // 获取 class 对象，因为后面创建动态代理的类需要类加载器，然后通过 class 对象和类加载器创建对象
        Class<?> cls = rs.getClass();

        Subject subject = (Subject) Proxy.newProxyInstance(cls.getClassLoader(),
                cls.getInterfaces(), ds);

        subject.request();
        System.out.println(subject.getClass());
        System.out.println(subject.getClass().getSuperclass());
    }
}

/** output:
 *  before calling: public abstract void com.gjxaiou.bytecode.Subject.request()
 *  From real subject
 *  after calling: public abstract void com.gjxaiou.bytecode.Subject.request()
 *  class com.sun.proxy.$Proxy0
 *  class java.lang.reflect.Proxy
 */

```

