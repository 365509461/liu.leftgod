{"compress":true,"commitItems":[["c83d87c5-259a-40fd-8b53-6b8091295768",1573562014899,"# 第 6 章  工厂模式\n\n## 6.1 简单工厂模式\n\n### 6.1.1 看一个具体的需求\n\n看一个披萨的项目：要便于披萨种类的扩展，要便于维护\n\n1) 披萨的种类很多(比如 GreekPizz、CheesePizz 等)\n\n2) 披萨的制作有 prepare，bake, cut, box\n\n3) 完成披萨店订购功能。\n\n### 6.1.2 使用传统的方式来完成\n\n1) 思路分析(类图)\n\n编写 OrderPizza.java 去订购需要的各种 Pizza\n\n2) 看老师代码的演示\n\n| \n\npublic class OrderPizza {\n\n |\n\n| \n\n// 构造器\n\n// public OrderPizza()  {\n\n// Pizza pizza =  null;\n\n// String  orderType; // 订购披萨的类型\n\n// do {\n\n// orderType =  getType();\n\n// if (orderType.equals(\"greek\"))  {\n\n// pizza = new  GreekPizza();\n\n// pizza.setName(\" 希腊披萨 \");\n\n// } else if (orderType.equals(\"cheese\"))  {\n\n// pizza = new  CheesePizza();\n\n// pizza.setName(\" 奶酪披萨 \");\n\n// } else if (orderType.equals(\"pepper\"))  {\n\n// pizza = new  PepperPizza();\n\n// pizza.setName(\"胡椒披萨\");\n\n// } else  {\n\n// break;\n\n// }\n\n// //输出 pizza 制作过程\n\n// pizza.prepare();\n\n// pizza.bake();\n\n// pizza.cut();\n\n// pizza.box();\n\n//\n\n// } while  (true);\n\n// }\n\n |\n\n### 6.1.3 传统的方式的优缺点\n\n1) 优点是比较好理解，简单易操作。\n\n2) 缺点是违反了设计模式的 **ocp** **原则**，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.\n\n3) 比如我们这时**要新增加一个** **Pizza** **的种类****(Pepper** **披萨****)**，我们需要做如下修改. 如果我们增加一个 Pizza 类，只要是订购 Pizza 的代码都需要修改.\n\n4) 改进的思路分析\n\n分析：修改代码可以接受，但是如果我们在其它的地方也有创建 Pizza 的代码，就意味着，也需要修改，而创建 Pizza\n\n的代码，往往有多处。\n\n思路：**把创建** **Pizza** **对象封装到一个类中，这样我们有新的** **Pizza** **种类时，只需要修改该类就可**，其它有创建到 Pizza\n\n对象的代码就不需要修改了.-> **简单工厂**模式\n\n### 6.1.4 基本介绍\n\n1) 简单工厂模式是属于**创建型模式**，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是**工厂模式家族中最简单实用的**模式\n\n2) 简单工厂模式：定义了一个创建对象的类，由这个类来**封装实例化对象的行为**(代码)\n\n3) 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.\n\n### 6.1.5 使用简单工厂模式\n\n1) 简单工厂模式的设计方案: 定义一个可以实例化 Pizaa 对象的类，封装创建对象的代码。\n\n2) 看代码示例\n\n| \n\npackage com.atguigu.factory.simplefactory.pizzastore.order;\n\nimport com.atguigu.factory.simplefactory.pizzastore.pizza.CheesePizza; import com.atguigu.factory.simplefactory.pizzastore.pizza.GreekPizza; import com.atguigu.factory.simplefactory.pizzastore.pizza.PepperPizza; import com.atguigu.factory.simplefactory.pizzastore.pizza.Pizza;\n\n |\n\n| \n\n//简单工厂类\n\npublic class **SimpleFactory** {\n\n//更加 orderType 返回对应的 Pizza 对象\n\npublic Pizza createPizza(String orderType) {\n\nPizza pizza = null;\n\nSystem.out.println(\"使用简单工厂模式\"); if (orderType.equals(\"greek\")) {\n\npizza = new GreekPizza(); pizza.setName(\" 希腊披萨 \");\n\n} else if (orderType.equals(\"cheese\")) {\n\npizza = new CheesePizza(); pizza.setName(\" 奶酪披萨 \");\n\n} else if (orderType.equals(\"pepper\")) {\n\npizza = new PepperPizza(); pizza.setName(\"胡椒披萨\");\n\n}\n\nreturn pizza;\n\n}\n\n//简单工厂模式 也叫 静态工厂模式\n\n |\n\n| \n\npublic static Pizza createPizza2(String orderType) {\n\nPizza pizza = null;\n\nSystem.out.println(\"使用简单工厂模式 2\"); if (orderType.equals(\"greek\")) {\n\npizza = new GreekPizza(); pizza.setName(\" 希腊披萨 \");\n\n} else if (orderType.equals(\"cheese\")) {\n\npizza = new CheesePizza(); pizza.setName(\" 奶酪披萨 \");\n\n} else if (orderType.equals(\"pepper\")) {\n\npizza = new PepperPizza(); pizza.setName(\"胡椒披萨\");\n\n}\n\nreturn pizza;\n\n}\n\n}\n\n |\n| \n\n//OrderPizza.java\n\npackage com.atguigu.factory.simplefactory.pizzastore.order;\n\nimport java.io.BufferedReader;\n\n |\n\n| \n\nimport java.io.IOException; import  java.io.InputStreamReader;\n\nimport com.atguigu.factory.simplefactory.pizzastore.pizza.Pizza;\n\npublic class OrderPizza {\n\n// 构造器\n\n// public OrderPizza()  {\n\n// Pizza pizza =  null;\n\n// String  orderType; // 订购披萨的类型\n\n// do {\n\n// orderType =  getType();\n\n// if (orderType.equals(\"greek\"))  {\n\n// pizza = new  GreekPizza();\n\n// pizza.setName(\" 希腊披萨 \");\n\n// } else if (orderType.equals(\"cheese\"))  {\n\n// pizza = new  CheesePizza();\n\n// pizza.setName(\" 奶酪披萨 \");\n\n// } else if (orderType.equals(\"pepper\"))  {\n\n// pizza = new  PepperPizza();\n\n// pizza.setName(\"胡椒披萨\");\n\n// } else  {\n\n// break;\n\n// }\n\n |\n\n| \n\n// //输出 pizza 制作过程\n\n// pizza.prepare();\n\n// pizza.bake();\n\n// pizza.cut();\n\n// pizza.box();\n\n//\n\n// } while  (true);\n\n// }\n\n//定义一个简单工厂对象SimpleFactory simpleFactory; Pizza pizza = null;\n\n//构造器\n\npublic OrderPizza(SimpleFactory simpleFactory) { setFactory(simpleFactory);\n\n}\n\npublic void setFactory(SimpleFactory simpleFactory) {\n\nString orderType = \"\"; //用户输入的\n\nthis.simpleFactory = simpleFactory; //设置简单工厂对象\n\ndo {\n\norderType = getType();\n\npizza = this.simpleFactory.createPizza(orderType);\n\n |\n\n| \n\n//输出 pizza\n\nif(pizza != null) { //订购成功pizza.prepare(); pizza.bake();\n\npizza.cut();\n\npizza.box();\n\n} else {\n\nSystem.out.println(\" 订购披萨失败 \"); break;\n\n}\n\n}while(true);\n\n}\n\n// 写一个方法，可以获取客户希望订购的披萨种类\n\nprivate String getType() { try {\n\nBufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\");\n\nString str = strin.readLine();\n\nreturn str;\n\n} catch (IOException e) { e.printStackTrace(); return \"\";\n\n}\n\n}\n\n |\n\n| \n\n}\n\n |\n\n## 6.2 工厂方法模式\n\n### 6.2.1 看一个新的需求\n\n披萨项目新的需求：客户在点披萨时，可以点**不同口味的披萨**，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza。\n\n### 6.2.2 思路 1\n\n使用**简单工厂模式**，创建**不同的简单工厂类**，比如 BJPizzaSimpleFactory、LDPizzaSimpleFactory 等等.从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好\n\n### 6.2.3 思路 2\n\n使用工厂方法模式\n\n### 6.2.4 工厂方法模式介绍\n\n1) 工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。\n\n2) 工厂方法模式：**定义了一个创建对象的抽象方法**，由子**类决定要实例化的类**。工厂方法模式将**对象的实例化推迟到子类**。\n\n### 6.2.5 工厂方法模式应用案例\n\n1) 披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza\n\n2) 思路分析图解\n\n3) 看老师代码实现\n\n| \n\n//OrderPizza.java 类\n\npackage com.atguigu.factory.factorymethod.pizzastore.order;\n\nimport java.io.BufferedReader; import java.io.IOException; import  java.io.InputStreamReader;\n\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.Pizza;\n\n |\n\n| \n\npublic abstract class OrderPizza {\n\n//定义一个抽象方法，createPizza , 让各个工厂子类自己实现\n\nabstract Pizza createPizza(String orderType);\n\n// 构造器\n\npublic OrderPizza() { Pizza pizza = null;\n\nString orderType; // 订购披萨的类型\n\ndo {\n\norderType = getType();\n\npizza = createPizza(orderType); //抽象方法，由工厂子类完成\n\n//输出 pizza 制作过程pizza.prepare(); pizza.bake();\n\npizza.cut();\n\npizza.box();\n\n} while (true);\n\n}\n\n |\n\n| \n\n// 写一个方法，可以获取客户希望订购的披萨种类\n\nprivate String getType() { try {\n\nBufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\");\n\nString str = strin.readLine();\n\nreturn str;\n\n} catch (IOException e) { e.printStackTrace(); return \"\";\n\n}\n\n}\n\n}\n\n |\n| \n\npackage com.atguigu.factory.factorymethod.pizzastore.order;\n\nimport  com.atguigu.factory.factorymethod.pizzastore.pizza.BJCheesePizza; import com.atguigu.factory.factorymethod.pizzastore.pizza.BJPepperPizza; import  com.atguigu.factory.factorymethod.pizzastore.pizza.Pizza;\n\npublic class **BJOrderPizza** extends OrderPizza {\n\n |\n\n| \n\n@Override\n\nPizza createPizza(String orderType) {\n\nPizza pizza = null; if(orderType.equals(\"cheese\")) {\n\npizza = new  BJCheesePizza();\n\n} else if (orderType.equals(\"pepper\"))  { pizza = new  BJPepperPizza();\n\n}\n\n// TODO Auto-generated method stub return pizza;\n\n}\n\n}\n\n |\n| \n\npackage com.atguigu.factory.factorymethod.pizzastore.order;\n\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.BJCheesePizza; import com.atguigu.factory.factorymethod.pizzastore.pizza.BJPepperPizza; import  com.atguigu.factory.factorymethod.pizzastore.pizza.LDCheesePizza; import com.atguigu.factory.factorymethod.pizzastore.pizza.LDPepperPizza; import  com.atguigu.factory.factorymethod.pizzastore.pizza.Pizza;\n\npublic class LDOrderPizza extends OrderPizza {\n\n |\n\n| \n\n@Override\n\nPizza createPizza(String orderType) {\n\nPizza pizza = null; if(orderType.equals(\"cheese\")) {\n\npizza = new  LDCheesePizza();\n\n} else if (orderType.equals(\"pepper\"))  { pizza = new  LDPepperPizza();\n\n}\n\n// TODO Auto-generated method stub return pizza;\n\n}\n\n}\n\n |\n\n## 6.3 抽象工厂模式\n\n### 6.3.1 基本介绍\n\n1) 抽象工厂模式：定义了一个 **interface** **用于创建相关或有依赖关系的对象簇**，而无需指明具体的类\n\n2) 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。\n\n3) 从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。\n\n4) 将工厂抽象成**两层**，**AbsFactory(****抽象工厂****)** 和 **具体实现的工厂子类**。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。\n\n5) 类图\n\n### 6.3.2 抽象工厂模式应用实例\n\n使用抽象工厂模式来完成披萨项目.\n\n| \n\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\nimport com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;\n\n//一个抽象工厂模式的抽象层(接口) public interface AbsFactory {\n\n//让下面的工厂子类来 具体实现\n\npublic Pizza createPizza(String orderType);\n\n}\n\n |\n\n| \n\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\nimport  com.atguigu.factory.absfactory.pizzastore.pizza.BJCheesePizza; import  com.atguigu.factory.absfactory.pizzastore.pizza.BJPepperPizza; import  com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;\n\n//这是工厂子类\n\npublic class BJFactory implements AbsFactory {\n\n@Override\n\npublic Pizza createPizza(String orderType) { System.out.println(\"~使用的是抽象工厂模式~\");\n\n// TODO Auto-generated method stub\n\nPizza pizza = null; if(orderType.equals(\"cheese\")) {\n\npizza = new  BJCheesePizza();\n\n} else if  (orderType.equals(\"pepper\")){ pizza = new  BJPepperPizza();\n\n}\n\nreturn pizza;\n\n}\n\n}\n\n |\n| \n\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\n |\n\n| \n\nimport  com.atguigu.factory.absfactory.pizzastore.pizza.LDCheesePizza; import  com.atguigu.factory.absfactory.pizzastore.pizza.LDPepperPizza; import  com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;\n\npublic class LDFactory implements AbsFactory {\n\n@Override\n\npublic Pizza createPizza(String orderType) { System.out.println(\"~使用的是抽象工厂模式~\"); Pizza pizza = null;\n\nif (orderType.equals(\"cheese\")) { pizza = new  LDCheesePizza();\n\n} else if (orderType.equals(\"pepper\"))  { pizza = new  LDPepperPizza();\n\n}\n\nreturn pizza;\n\n}\n\n}\n\n |\n| \n\n//OrderPizza.java\n\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\nimport java.io.BufferedReader;\n\n |\n\n| \n\nimport java.io.IOException; import  java.io.InputStreamReader;\n\nimport com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;\n\npublic class OrderPizza {\n\nAbsFactory factory;\n\n// 构造器\n\npublic OrderPizza(AbsFactory factory) { setFactory(factory);\n\n}\n\nprivate void setFactory(AbsFactory factory) { Pizza pizza = null;\n\nString orderType = \"\"; // 用户输入\n\nthis.factory = factory; do {\n\norderType = getType();\n\n// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类\n\npizza = factory.createPizza(orderType); if (pizza != null) { // 订购 ok\n\npizza.prepare();\n\npizza.bake();\n\npizza.cut();\n\n |\n\n| \n\npizza.box();\n\n} else {\n\nSystem.out.println(\"订购失败\"); break;\n\n}\n\n} while (true);\n\n}\n\n// 写一个方法，可以获取客户希望订购的披萨种类\n\nprivate String getType() { try {\n\nBufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\");\n\nString str = strin.readLine();\n\nreturn str;\n\n} catch (IOException e) { e.printStackTrace(); return \"\";\n\n}\n\n}\n\n}\n\n |\n\n## 6.4 工厂模式在 JDK-Calendar 应用的源码分析\n\n1) JDK 中的 Calendar 类中，就使用了简单工厂模式\n\n2) 源码分析+Debug 源码+说明\n\nØ 源码部分\n\n| \n\npackage  com.atguigu.jdk;\n\nimport  java.util.Calendar;\n\npublic class Factory {\n\npublic static void main(String[] args) {\n\n// TODO Auto-generated method stub\n\n// getInstance 是 Calendar 静态方法\n\nCalendar cal = **Calendar.getInstance**();\n\n// 注意月份下标从 0 开始，所以取月份要+1 System.out.println(\" 年 :\" + cal.get(Calendar.YEAR)); System.out.println(\" 月 :\" + (cal.get(Calendar.MONTH) + 1)); System.out.println(\"日:\" + cal.get(Calendar.DAY_OF_MONTH)); System.out.println(\"时:\" + cal.get(Calendar.HOUR_OF_DAY)); System.out.println(\" 分 :\" + cal.get(Calendar.MINUTE)); System.out.println(\"秒:\" + cal.get(Calendar.SECOND));\n\n}\n\n}\n\n |\n| \n\n//Calendar.java\n\n |\n\n| \n\npublic static Calendar getInstance()\n\n{\n\nreturn createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));\n\n}\n\n |\n| \n\nprivate static Calendar createCalendar(TimeZone zone,\n\nLocale aLocale) //根据 TimeZone zone, locale 创建对应的实例\n\n{\n\nCalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)\n\n.getCalendarProvider();\n\nif (provider != null) { try {\n\nreturn provider.getInstance(zone, aLocale);\n\n} catch (IllegalArgumentException iae) {\n\n// fall back to the default instantiation\n\n}\n\n}\n\nCalendar cal = null;\n\nif (aLocale.hasExtensions()) {\n\nString caltype = aLocale.getUnicodeLocaleType(\"ca\"); if (caltype != null) {\n\n |\n\n| \n\nswitch (caltype) { case \"buddhist\":\n\ncal = **new BuddhistCalendar(zone, aLocale);**\n\nbreak;\n\ncase \"japanese\":\n\ncal = **new JapaneseImperialCalendar(zone, aLocale);**\n\nbreak; case \"gregory\":\n\ncal = **new GregorianCalendar(zone, aLocale);**\n\nbreak;\n\n}\n\n}\n\n}\n\nif (cal == null) {\n\n// If no known calendar type is explicitly  specified,\n\n// perform the traditional way to create a  Calendar:\n\n// create a BuddhistCalendar for th_TH locale,\n\n// a JapaneseImperialCalendar for ja_JP_JP locale, or\n\n// a GregorianCalendar for any other locales.\n\n// NOTE: The language, country and variant strings are interned.\n\nif (aLocale.getLanguage() == \"th\" && aLocale.getCountry() == \"TH\") { cal = new BuddhistCalendar(zone, aLocale);\n\n} else if (aLocale.getVariant() == \"JP\" && aLocale.getLanguage() == \"ja\" && aLocale.getCountry() == \"JP\") {\n\ncal = new JapaneseImperialCalendar(zone, aLocale);\n\n} else {\n\n |\n\n| \n\ncal = new GregorianCalendar(zone, aLocale);\n\n}\n\n}\n\nreturn cal;\n\n}\n\n |\n\n## 6.5 工厂模式小结\n\n1) 工厂模式的意义\n\n将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。\n\n2) 三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)\n\n3) 设计模式的依赖抽象原则\n\nØ 创建对象实例时，不要直接 new 类, 而是把这个 new 类的动作放在一个工厂的方法中，并返回。有的书上说， 变量不要直接持有具体类的引用。\n\nØ 不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)\n\nØ 不要覆盖基类中已经实现的方法。",[[1573562013872,["GJX@GJXAIOU",[[-1,3," 6 "]],[6,6],[3,3]]],[1573562015992,["GJX@GJXAIOU",[[1,3,"六"]],[3,3],[4,4]]],[1573562022197,["GJX@GJXAIOU",[[-1,5,"  "]],[7,7],[5,5]]],[1573562023424,["GJX@GJXAIOU",[[1,5,"："]],[5,5],[6,6]]],[1573562027541,["GJX@GJXAIOU",[[-1,15,"6.1 "]],[15,19],[15,15]]],[1573562029303,["GJX@GJXAIOU",[[1,15,"一、"]],[15,15],[17,17]]],[1573562119508,["GJX@GJXAIOU",[[-1,29,"6.1.1 "]],[35,35],[29,29]]],[1573562120504,["GJX@GJXAIOU",[[1,29,"（）"]],[29,29],[31,31]]],[1573562122240,["GJX@GJXAIOU",[[1,30,"一"]],[30,30],[31,31]]],[1573562129779,["GJX@GJXAIOU",[[-1,161,"6.1.2 "]],[161,167],[161,161]]],[1573562130751,["GJX@GJXAIOU",[[1,161,"（）"]],[161,161],[163,163]]],[1573562132266,["GJX@GJXAIOU",[[1,162,"二"]],[162,162],[163,163]]],[1573562230018,["GJX@GJXAIOU",[[1,116,"步骤"]],[116,116],[118,118]]],[1573562232752,["GJX@GJXAIOU",[[1,119,"："]],[119,119],[120,120]]],[1573562239499,["GJX@GJXAIOU",[[-1,108,"2)"]],[110,110],[108,108]]],[1573562240533,["GJX@GJXAIOU",[[1,108,"-"]],[108,108],[109,109]]],[1573562240927,["GJX@GJXAIOU",[[1,110," "]],[109,109],[110,110]]],[1573562242557,["GJX@GJXAIOU",[[-1,110," "]],[111,111],[110,110]]],[1573562244933,["GJX@GJXAIOU",[[-1,144,"3)"]],[146,146],[144,144]]],[1573562245347,["GJX@GJXAIOU",[[-1,143,"\n"]],[144,144],[143,143]]],[1573562246271,["GJX@GJXAIOU",[[1,143,"-"]],[143,143],[144,144]]],[1573562248228,["GJX@GJXAIOU",[[-1,107,"\n"]],[107,107],[106,106]]],[1573562254506,["GJX@GJXAIOU",[[-1,69,"1)"]],[71,71],[69,69]]],[1573562255479,["GJX@GJXAIOU",[[1,69,"-"]],[69,69],[70,70]]],[1573562257709,["GJX@GJXAIOU",[[-1,68,"\n"]],[68,68],[67,67]]],[1573562462908,["GJX@GJXAIOU",[[-1,186,"编写 OrderPizza.java 去订购需要的各种 Pizza"]],[186,219],[186,186]]],[1573562465701,["GJX@GJXAIOU",[[-1,173,"1)"]],[173,175],[173,173]]],[1573562466106,["GJX@GJXAIOU",[[1,173,"-"]],[173,173],[174,174]]],[1573562474026,["GJX@GJXAIOU",[[1,185,"![传统思路]($resource/%E4%BC%A0%E7%BB%9F%E6%80%9D%E8%B7%AF.jpg)"]],[185,185],[245,245]]],[1573562534628,["GJX@GJXAIOU",[[-1,259,"| \n\npublic class OrderPizza {\n\n |\n\n| \n\n// 构造器\n\n// public OrderPizza()  {\n\n// Pizza pizza =  null;\n\n// String  orderType; // 订购披萨的类型\n\n// do {\n\n// orderType =  getType();\n\n// if (orderType.equals(\"greek\"))  {\n\n// pizza = new  GreekPizza();\n\n// pizza.setName(\" 希腊披萨 \");\n\n// } else if (orderType.equals(\"cheese\"))  {\n\n// pizza = new  CheesePizza();\n\n// pizza.setName(\" 奶酪披萨 \");\n\n// } else if (orderType.equals(\"pepper\"))  {\n\n// pizza = new  PepperPizza();\n\n// pizza.setName(\"胡椒披萨\");\n\n// } else  {\n\n// break;\n\n// }\n\n// //输出 pizza 制作过程\n\n// pizza.prepare();\n\n// pizza.bake();\n\n// pizza.cut();\n\n// pizza.box();\n\n//\n\n// } while  (true);\n\n// }\n\n |"]],[259,896],[259,259]]],[1573562540248,["GJX@GJXAIOU",[[1,259,"·"]],[259,259],[260,260]]],[1573562541059,["GJX@GJXAIOU",[[-1,259,"·"]],[260,260],[259,259]]],[1573562541531,["GJX@GJXAIOU",[[-1,260,"\n"]],[259,259],[258,258]]],[1573562543798,["GJX@GJXAIOU",[[1,258,"```"]],[258,258],[261,261]]],[1573562543936,["GJX@GJXAIOU",[[1,261,"language\n```\n"]],[261,261],[261,269]]],[1573562545608,["GJX@GJXAIOU",[[-1,261,"language"],[1,269,"j"]],[261,269],[262,262]]],[1573562546170,["GJX@GJXAIOU",[[1,262,"ava"]],[262,262],[265,265]]],[1573562546518,["GJX@GJXAIOU",[[1,266,"\n"]],[265,265],[266,266]]],[1573562723918,["GJX@GJXAIOU",[[1,266,"public calss"]],[266,266],[278,278]]],[1573562725734,["GJX@GJXAIOU",[[-1,274,"alss"]],[278,278],[274,274]]],[1573562727005,["GJX@GJXAIOU",[[1,274,"lass"]],[274,274],[278,278]]],[1573562731685,["GJX@GJXAIOU",[[-1,273,"class"]],[278,278],[273,273]]],[1573562734503,["GJX@GJXAIOU",[[1,273,"abstract"]],[273,273],[281,281]]],[1573562744798,["GJX@GJXAIOU",[[1,281," class Pizzz"]],[281,281],[293,293]]],[1573562745717,["GJX@GJXAIOU",[[-1,292,"z"]],[293,293],[292,292]]],[1573562747370,["GJX@GJXAIOU",[[1,292,"a{}"]],[292,292],[295,295]]],[1573562748637,["GJX@GJXAIOU",[[1,294,"\n"]],[294,294],[295,295]]],[1573562749437,["GJX@GJXAIOU",[[1,295,"\n"]],[295,295],[296,296]]],[1573562750884,["GJX@GJXAIOU",[[1,296,"\n"]],[296,296],[297,297]]],[1573562755907,["GJX@GJXAIOU",[[1,295,"    pritec"]],[295,295],[305,305]]],[1573562760627,["GJX@GJXAIOU",[[-1,301,"itec"]],[305,305],[301,301]]],[1573562764198,["GJX@GJXAIOU",[[1,301,"otect s"]],[301,301],[308,308]]],[1573562764612,["GJX@GJXAIOU",[[-1,307,"s"]],[308,308],[307,307]]],[1573562771010,["GJX@GJXAIOU",[[1,307,"String name;"]],[307,307],[319,319]]],[1573562772149,["GJX@GJXAIOU",[[1,320,"    \n"]],[319,319],[324,324]]],[1573562775031,["GJX@GJXAIOU",[[1,324,"po"]],[324,324],[326,326]]],[1573562776077,["GJX@GJXAIOU",[[-1,325,"o"]],[326,326],[325,325]]],[1573562779737,["GJX@GJXAIOU",[[1,325,"ublic a"]],[325,325],[332,332]]]],null,"GJX@GJXAIOU"]]}